<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JSON Graph Visualizer</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .container { max-width: 700px; margin: auto; }
        #drop-area { border:2px dashed #aaa; border-radius:8px; padding:30px; text-align:center; margin-bottom:20px; background:#fafafa; }
        input[type="file"] { display:none; }
        button { padding: 10px 20px; margin-bottom: 10px; }
        #result { margin-top: 20px; }
        #graph { width: 100%; height: 500px; border: 1px solid #ccc; background: #fff; }
        #tables-flex {
            display: flex;
            gap: 32px;
            margin-bottom: 1em;
        }
        .table-section {
            flex: 1;
            min-width: 280px;
        }
    </style>
    <!-- Vis.js for graph visualization -->
    <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
    <link href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div class="container">
    <h2>JSON Graph Visualizer</h2>
    <div id="drop-area">
        <p>Drag & drop your JSON file here</p>
        <input type="file" id="inputFile" accept=".json">
        <button id="browseBtn" type="button">Browse File</button>
    </div>
    <div id="result"></div>
    <button id="downloadJsonBtn" type="button">Download JSON (nodes/edges)</button>
    <button id="downloadHierarchyBtn" type="button">Download Hierarchy JSON</button>
    <div id="tables-container"></div>
    <div id="graph"></div>
</div>
<script>
// Utility: convert a hierarchical JSON into nodes/edges
function hierarchyToGraph(data) {
    const nodes = [];
    const edges = [];
    const idMap = new Map();
    let nextId = 1;

    function makeId(preferred) {
        if (preferred !== undefined && preferred !== null && preferred !== '') {
            const s = String(preferred);
            if (!idMap.has(s)) {
                idMap.set(s, s);
                return s;
            }
            // fallback to numeric if collision
        }
        let id;
        do { id = 'n' + (nextId++); } while (idMap.has(id));
        idMap.set(id, id);
        return id;
    }

    function addNode(id, label) {
        nodes.push({ id, label: label === undefined ? String(id) : label });
    }

    function visit(node, parentId) {
        if (node == null) return;
        // If node is a primitive, create a node for it
        if (typeof node === 'string' || typeof node === 'number' || typeof node === 'boolean') {
            const id = makeId(String(node));
            addNode(id, String(node));
            if (parentId) edges.push({ from: parentId, to: id, label: '' });
            return id;
        }

        // If node is an array, visit each element
        if (Array.isArray(node)) {
            let lastId = null;
            node.forEach(el => {
                const childId = visit(el, parentId);
                lastId = childId || lastId;
            });
            return lastId;
        }

        // node is an object
        // If object looks like {id, name/label, children}
        let label = node.label || node.name || node.title || node.id || undefined;
        // Prefer explicit id property if present
        let preferredId = node.id !== undefined ? String(node.id) : undefined;
        const myId = makeId(preferredId);
        addNode(myId, label !== undefined ? String(label) : myId);
        if (parentId) edges.push({ from: parentId, to: myId, label: '' });

        // If object has a children array, traverse it
        if (Array.isArray(node.children) && node.children.length) {
            node.children.forEach(child => visit(child, myId));
        } else {
            // Otherwise, treat other keys whose values are arrays/objects as children
            Object.keys(node).forEach(k => {
                if (['id','label','name','title'].includes(k)) return;
                const v = node[k];
                if (v == null) return;
                // If value is array/object, create implicit child node for key then attach
                if (Array.isArray(v)) {
                    // If array of primitives, create child nodes under this object
                    if (v.every(x => typeof x !== 'object')) {
                        v.forEach(prim => visit(prim, myId));
                    } else {
                        visit(v, myId);
                    }
                } else if (typeof v === 'object') {
                    // If the key looks like a single child object with a label equal to key, create a key-node wrapper
                    // but more useful is to recurse into the object and attach its contents to current node
                    visit(v, myId);
                }
            });
        }
        return myId;
    }

    // Entry points: if data is array, iterate; if object that maps labels to arrays, detect that
    if (Array.isArray(data)) {
        data.forEach(el => visit(el, null));
    } else if (typeof data === 'object') {
        // If top-level keys appear to be labels mapping to arrays/objects (like {A: {...}, B: {...}})
        const topKeysAreNodes = Object.keys(data).length > 0 && Object.values(data).every(v => typeof v !== 'string' || Array.isArray(v) || typeof v === 'object');
        // If object has a single root-like shape (has name/children), just visit it
        if (data.name || data.label || data.children) {
            visit(data, null);
        } else if (topKeysAreNodes) {
            // treat each key as a node with children = value
            Object.keys(data).forEach(k => {
                const wrapper = { name: k, children: Array.isArray(data[k]) ? data[k] : [data[k]] };
                visit(wrapper, null);
            });
        } else {
            // fallback: visit the object itself
            visit(data, null);
        }
    }

    // Deduplicate nodes (by id) - nodes were added in order, ensure unique by id
    const seen = new Map();
    const outNodes = [];
    nodes.forEach(n => {
        if (!seen.has(n.id)) { seen.set(n.id, true); outNodes.push(n); }
    });

    return { nodes: outNodes, edges };
}

// Convert nodes/edges back into a simple hierarchy JSON using { name, children } format
function graphToHierarchy(nodes, edges) {
    const nodeMap = new Map();
    nodes.forEach(n => nodeMap.set(String(n.id), { id: String(n.id), name: n.label || String(n.id), children: [] }));
    const incoming = new Map();
    edges.forEach(e => {
        const from = String(e.from), to = String(e.to);
        if (!nodeMap.has(from) || !nodeMap.has(to)) return;
        nodeMap.get(from).children.push(nodeMap.get(to));
        incoming.set(to, (incoming.get(to) || 0) + 1);
    });
    // roots are nodes with no incoming edges
    const roots = [];
    nodeMap.forEach((v, k) => { if (!incoming.has(k)) roots.push(v); });
    // If no roots (cycle or disconnected), return all nodes as top-level
    if (roots.length === 0) return Array.from(nodeMap.values()).map(n => ({ name: n.name, children: n.children.length ? n.children : undefined }));
    // Clean up children arrays: remove id references
    function clean(node) {
        const out = { name: node.name };
        if (node.children && node.children.length) {
            out.children = node.children.map(c => clean(c));
        }
        return out;
    }
    return roots.map(r => clean(r));
}

// Helper: take any loaded JSON and return {nodes, edges} for the rest of the app
function parseToGraph(json) {
    if (!json) return { nodes: [], edges: [] };
    if (Array.isArray(json) && json.length && json[0] && (json[0].from !== undefined || json[0].to !== undefined)) {
        // array of edges or mixed; try to split
        const nodes = json.filter(x => x.id !== undefined).map(x => ({ id: x.id, label: x.label || String(x.id) }));
        const edges = json.filter(x => x.from !== undefined && x.to !== undefined).map(x => ({ from: x.from, to: x.to, label: x.label || '' }));
        return { nodes, edges };
    }
    if (json.nodes && json.edges && Array.isArray(json.nodes) && Array.isArray(json.edges)) {
        return { nodes: json.nodes.map(n => ({ id: n.id, label: n.label || String(n.id) })), edges: json.edges.map(e => ({ from: e.from, to: e.to, label: e.label || '' })) };
    }
    // Otherwise try to treat as hierarchy
    return hierarchyToGraph(json);
}

// Load sample JSON on startup
fetch('sample/vocalization_hierarchy.json')
    .then(response => {
        if (!response.ok) throw new Error("Sample JSON file not found.");
        return response.text();
    })
    .then(jsonText => {
        let json;
        try {
            json = JSON.parse(jsonText);
        } catch (err) {
            document.getElementById('result').innerText = 'Invalid sample JSON.';
            return;
        }
        document.getElementById('result').innerText = "Loaded sample: vocalization_hierarchy.json";
        currentJson = json;
        const graph = parseToGraph(json);
        renderTables({ nodes: graph.nodes, edges: graph.edges });
        visualizeGraph({ nodes: graph.nodes, edges: graph.edges });
    })
    .catch(err => {
        document.getElementById('result').innerHTML = "<b>Could not load sample/vocalization_hierarchy.json.</b>";
    });
document.getElementById('downloadJsonBtn').onclick = function() {
    // Get current nodes and edges from the tables
    let nodes = [];
    let edges = [];
    // Try to get from last renderTables call
    const container = document.getElementById('tables-container');
    const tables = container.getElementsByTagName('table');
    if (tables.length >= 2) {
        // Nodes table
        const nodeRows = tables[0].rows;
        for (let i = 1; i < nodeRows.length; i++) {
            let id = nodeRows[i].cells[0].textContent;
            let label = nodeRows[i].cells[1].textContent;
            if (id !== '' || label !== '') nodes.push({id, label});
        }
        // Edges table
        const edgeRows = tables[1].rows;
        for (let i = 1; i < edgeRows.length; i++) {
            let from = edgeRows[i].cells[0].textContent;
            let to = edgeRows[i].cells[1].textContent;
            let label = edgeRows[i].cells[2].textContent;
            if (from !== '' || to !== '' || label !== '') edges.push({from, to, label});
        }
    }
    let jsonOut = JSON.stringify({nodes, edges}, null, 2);
    const blob = new Blob([jsonOut], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    // Use original filename if available, else fallback
    let originalFilename = (window.droppedFile && window.droppedFile.name) || (window.uploadedFileName) || 'graph.json';
    let baseName = originalFilename.replace(/\.json$/i, '');
    let now = new Date();
    let pad = n => n.toString().padStart(2, '0');
    let timestamp = `${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    a.download = `${baseName}_${timestamp}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};
// New: download hierarchy JSON reconstructed from current nodes/edges
document.getElementById('downloadHierarchyBtn').onclick = function() {
    let nodes = [];
    let edges = [];
    const container = document.getElementById('tables-container');
    const tables = container.getElementsByTagName('table');
    if (tables.length >= 2) {
        const nodeRows = tables[0].rows;
        for (let i = 1; i < nodeRows.length; i++) {
            let id = nodeRows[i].cells[0].textContent;
            let label = nodeRows[i].cells[1].textContent;
            if (id !== '' || label !== '') nodes.push({id, label});
        }
        const edgeRows = tables[1].rows;
        for (let i = 1; i < edgeRows.length; i++) {
            let from = edgeRows[i].cells[0].textContent;
            let to = edgeRows[i].cells[1].textContent;
            let label = edgeRows[i].cells[2].textContent;
            if (from !== '' || to !== '' || label !== '') edges.push({from, to, label});
        }
    }
    const hierarchy = graphToHierarchy(nodes, edges);
    let jsonOut = JSON.stringify(hierarchy.length === 1 ? hierarchy[0] : hierarchy, null, 2);
    const blob = new Blob([jsonOut], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    let originalFilename = (window.droppedFile && window.droppedFile.name) || (window.uploadedFileName) || 'hierarchy.json';
    let baseName = originalFilename.replace(/\.json$/i, '');
    let now = new Date();
    let pad = n => n.toString().padStart(2, '0');
    let timestamp = `${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    a.download = `${baseName}_hierarchy_${timestamp}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};
const dropArea = document.getElementById('drop-area');
const inputFile = document.getElementById('inputFile');
const browseBtn = document.getElementById('browseBtn');
let droppedFile = null;
let currentJson = null;

['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, preventDefaults, false);
});
function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
}
dropArea.addEventListener('dragover', () => {
    dropArea.style.background = '#e3e3e3';
});
dropArea.addEventListener('dragleave', () => {
    dropArea.style.background = '#fafafa';
});
dropArea.addEventListener('drop', handleDrop, false);
function handleDrop(e) {
    dropArea.style.background = '#fafafa';
    const dt = e.dataTransfer;
    const files = dt.files;
    if (files.length) {
        inputFile.files = files;
        droppedFile = files[0];
        window.droppedFile = droppedFile;
        dropArea.querySelector('p').textContent = `Selected: ${droppedFile.name}`;
        readAndVisualizeJson(droppedFile);
    }
}
browseBtn.addEventListener('click', () => {
    inputFile.click();
});
inputFile.addEventListener('change', () => {
    if (inputFile.files.length) {
        droppedFile = inputFile.files[0];
        window.droppedFile = droppedFile;
        window.uploadedFileName = droppedFile.name;
        dropArea.querySelector('p').textContent = `Selected: ${droppedFile.name}`;
        readAndVisualizeJson(droppedFile);
    }
});
function readAndVisualizeJson(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        let json;
        try {
            json = JSON.parse(e.target.result);
        } catch (err) {
            document.getElementById('result').innerText = 'Invalid JSON file.';
            return;
        }
        document.getElementById('result').innerText = 'File loaded!';
        currentJson = json;
        // Ensure any hierarchy input is converted to nodes/edges for rendering
        const graph = parseToGraph(json);
        renderTables({ nodes: graph.nodes, edges: graph.edges });
        visualizeGraph({ nodes: graph.nodes, edges: graph.edges });
    };
    reader.readAsText(file);
}
function visualizeGraph(data) {
    // Expecting { nodes: [...], edges: [...] }
    let nodes = [], edges = [];
    if (Array.isArray(data.nodes) && Array.isArray(data.edges)) {
        nodes = data.nodes.map(n => ({ id: n.id, label: n.label || String(n.id) }));
        edges = data.edges.map(e => ({ from: e.from, to: e.to, label: e.label || '' }));
    } else if (Array.isArray(data)) {
        // If data is an array, try to infer nodes/edges
        nodes = data.filter(x => x.id !== undefined).map(n => ({ id: n.id, label: n.label || String(n.id) }));
        edges = data.filter(x => x.from !== undefined && x.to !== undefined).map(e => ({ from: e.from, to: e.to, label: e.label || '' }));
    } else {
        document.getElementById('result').innerText = 'JSON must contain "nodes" and "edges" arrays.';
        return;
    }
    const container = document.getElementById('graph');
    container.innerHTML = '';
    const networkData = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };
    const options = {
        nodes: { shape: 'ellipse', size: 20, font: { size: 16 } },
        edges: { arrows: 'to', font: { align: 'middle' } },
        interaction: { hover: true, tooltipDelay: 100 },
        physics: { stabilization: true }
    };
    new vis.Network(container, networkData, options);
}

function renderTables(json) {
    let nodes = Array.isArray(json.nodes) ? json.nodes : [];
    let edges = Array.isArray(json.edges) ? json.edges : [];
    // If top-level is array, try to infer
    if (Array.isArray(json) && !json.nodes && !json.edges) {
        nodes = json.filter(x => x.id !== undefined);
        edges = json.filter(x => x.from !== undefined && x.to !== undefined);
    }
    const container = document.getElementById('tables-container');
    container.innerHTML = '';
    // Flex container for tables
    const flexDiv = document.createElement('div');
    flexDiv.id = 'tables-flex';
    // Nodes section
    const nodesSection = document.createElement('div');
    nodesSection.className = 'table-section';
    let nodesLabel = document.createElement('div');
    nodesLabel.innerHTML = '<b>Nodes</b>';
    const nodesTable = document.createElement('table');
    nodesTable.style.marginBottom = '1em';
    nodesTable.style.border = '1px solid #ccc';
    let nodeHeaders = ['id', 'label'];
    let nodeHeaderRow = document.createElement('tr');
    nodeHeaders.forEach(h => {
        let th = document.createElement('th');
        th.textContent = h;
        nodeHeaderRow.appendChild(th);
    });
    let thDelNode = document.createElement('th');
    thDelNode.textContent = '';
    nodeHeaderRow.appendChild(thDelNode);
    nodesTable.appendChild(nodeHeaderRow);
    nodes.forEach((node, i) => {
        let tr = document.createElement('tr');
        nodeHeaders.forEach((h, j) => {
            let td = document.createElement('td');
            td.contentEditable = 'true';
            td.textContent = node[h] !== undefined ? node[h] : '';
            td.addEventListener('input', () => {
                nodes[i][h] = td.textContent;
                visualizeGraph({nodes, edges});
            });
            tr.appendChild(td);
        });
        // Delete button for node
        let delBtn = document.createElement('button');
        delBtn.textContent = 'Delete';
        delBtn.style.marginLeft = '0.5em';
        delBtn.onclick = function() {
            nodes.splice(i, 1);
            renderTables({nodes, edges});
            visualizeGraph({nodes, edges});
        };
        let tdDel = document.createElement('td');
        tdDel.appendChild(delBtn);
        tr.appendChild(tdDel);
        nodesTable.appendChild(tr);
    });
    const addNodeBtn = document.createElement('button');
    addNodeBtn.textContent = 'Add Node';
    addNodeBtn.style.marginBottom = '1em';
    addNodeBtn.onclick = function() {
        nodes.push({id: '', label: ''});
        renderTables({nodes, edges});
        visualizeGraph({nodes, edges});
    };
    nodesSection.appendChild(nodesLabel);
    nodesSection.appendChild(nodesTable);
    nodesSection.appendChild(addNodeBtn);
    // Edges section
    const edgesSection = document.createElement('div');
    edgesSection.className = 'table-section';
    let edgesLabel = document.createElement('div');
    edgesLabel.innerHTML = '<b>Edges</b>';
    const edgesTable = document.createElement('table');
    edgesTable.style.marginBottom = '1em';
    edgesTable.style.border = '1px solid #ccc';
    let edgeHeaders = ['from', 'to', 'label'];
    let edgeHeaderRow = document.createElement('tr');
    edgeHeaders.forEach(h => {
        let th = document.createElement('th');
        th.textContent = h;
        edgeHeaderRow.appendChild(th);
    });
    let thDelEdge = document.createElement('th');
    thDelEdge.textContent = '';
    edgeHeaderRow.appendChild(thDelEdge);
    edgesTable.appendChild(edgeHeaderRow);
    edges.forEach((edge, i) => {
        let tr = document.createElement('tr');
        edgeHeaders.forEach((h, j) => {
            let td = document.createElement('td');
            td.contentEditable = 'true';
            td.textContent = edge[h] !== undefined ? edge[h] : '';
            td.addEventListener('input', () => {
                edges[i][h] = td.textContent;
                visualizeGraph({nodes, edges});
            });
            tr.appendChild(td);
        });
        // Delete button for edge
        let delBtn = document.createElement('button');
        delBtn.textContent = 'Delete';
        delBtn.style.marginLeft = '0.5em';
        delBtn.onclick = function() {
            edges.splice(i, 1);
            renderTables({nodes, edges});
            visualizeGraph({nodes, edges});
        };
        let tdDel = document.createElement('td');
        tdDel.appendChild(delBtn);
        tr.appendChild(tdDel);
        edgesTable.appendChild(tr);
    });
    const addEdgeBtn = document.createElement('button');
    addEdgeBtn.textContent = 'Add Edge';
    addEdgeBtn.style.marginBottom = '1em';
    addEdgeBtn.onclick = function() {
        edges.push({from: '', to: '', label: ''});
        renderTables({nodes, edges});
        visualizeGraph({nodes, edges});
    };
    edgesSection.appendChild(edgesLabel);
    edgesSection.appendChild(edgesTable);
    edgesSection.appendChild(addEdgeBtn);
    // Add both sections to flex container
    flexDiv.appendChild(nodesSection);
    flexDiv.appendChild(edgesSection);
    container.appendChild(flexDiv);
}
</script>
</body>
</html>
