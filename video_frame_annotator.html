<!--
Programmer Reference Summary
---------------------------
Video Frame Annotator: A browser-based tool for annotating video frames with points, bounding boxes, circles, and squares.

Key Features:
- Upload video via file input or drag & drop (no server, all client-side)
- Frame navigation: step, jump, play/pause, go to frame
- Annotation modes: Point (click), Bounding Box (click-drag), Circle (click-drag), Square (click-drag)
- Markers are stored per-frame, with undo/redo support for all actions
- Remove markers with shift+click or keyboard shortcut (Backspace)
- Tagging: hold any alphanumeric key (case-sensitive) while clicking to assign a tag to a marker
- Tag mapping UI: click "Tags" to show a list of all tags; each row has a color picker (leftmost), tag key, editable tag name, and alpha input
- Edit tag color and alpha: changing these updates all markers with that tag (RGB and alpha fields)
- Tag names (tag_name) are editable and exported/imported in both JSON and CSV; tag keys are case-sensitive
- Export annotations as JSON (with metadata and all marker types) or CSV (one row per marker, type, coordinates, color, tag, tag_name)
- Import annotations from JSON or CSV files, with option to merge or replace existing; tag_name and color are preserved if present
- FPS is estimated but user-editable; accurate FPS is critical for correct frame mapping
- Minimal CSS, no dependencies, no build step

Usage Instructions:
- Open the HTML file in a browser
- Load a video, set FPS if needed
- Select annotation mode, annotate frames as needed
- Use Undo/Redo, clear, and export as required
- Use the Tags UI to edit tag names, colors, and alpha; changes apply to all markers with that tag

Maintenance Notes:
- All logic is in this file (no external JS)
- Markers data structure: { [frameNumber]: [ {type, ...coords, r,g,b,a,tag,tag_name?} ] }
- Undo/redo stacks store operation objects for all marker types
- TagMap: { [tag]: { tag_name, color: {r,g,b,a} } } — updated on import/export and via UI
- UI and instructions are updated to reflect all annotation modes and tag features
- See README.md for project-wide conventions
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="Video Frame Annotator - A browser-based tool for annotating video frames with points, bounding boxes, circles, and squares. Navigate frame-by-frame, draw annotations with drag-and-drop, and export to JSON or CSV. Perfect for video analysis, object tracking, and dataset creation. No installation required." />
  <meta name="keywords" content="video annotation, frame annotator, bounding box, video labeling, object detection, computer vision, video analysis, dataset creation, frame-by-frame annotation, point annotation, circle annotation" />
  <title>Video Frame Annotator</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; margin: 20px; }
    #player { display:flex; gap:20px; align-items:flex-start; }
    video, canvas { background: #111; max-width: 80vw; border: 1px solid #ccc; }
    .controls { display:flex; gap:8px; flex-direction:column; }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    button { padding:6px 10px; }
    #pointsList { max-height:200px; overflow:auto; border:1px solid #eee; padding:8px; }
    .point-item { font-size:13px; }
    .hint { color:#666; font-size:13px; }
  </style>
</head>
<body>
  <h2>Video Frame Annotator</h2>
  <p class="hint">Upload a video, navigate frames, and annotate with points, bounding boxes, circles, or squares. Click/drag to add markers (shift+click to remove nearest). Export as JSON or CSV.</p>

  <div class="row">
    <input id="fileInput" type="file" accept="video/*" />
    <label><input id="frameStepInput" type="number" value="1" min="1" style="width:80px"> frames per step</label>
    <label title="Estimated FPS (editable)" style="color:red;"><strong>FPS:</strong> <input id="fpsInput" type="number" step="0.01" style="width:80px"> <span id="fpsWarn" style="margin-left:6px; visibility:hidden;" title="FPS is estimated — double-click to edit">⚠</span></label>
  </div>
  <div class="row">
    <strong>Annotation Mode:</strong>
    <label><input id="modePoint" type="radio" name="annotationMode" value="point" checked> Point</label>
    <label><input id="modeBox" type="radio" name="annotationMode" value="box"> Bounding Box</label>
  <label><input id="modeCircle" type="radio" name="annotationMode" value="circle"> Circle</label>
  <label><input id="modeSquare" type="radio" name="annotationMode" value="square"> Square</label>
  </div>
  <div class="row">
    <strong>Export Format:</strong>
    <label><input id="exportFormat" type="radio" name="format" value="json"> JSON</label>
    <label><input id="exportFormatCsv" type="radio" name="format" value="csv" checked> CSV</label>
    <button id="exportBtn">Export</button>
    <button id="undoBtn">Undo</button>
    <button id="redoBtn">Redo</button>
    <button id="clearBtn">Clear All Markers</button>
  </div>
  <div class="row">
    <label>Import annotations: <input id="importInput" type="file" accept=".json,.csv" /></label>
    <button id="importBtn">Import</button>
    <span class="hint">(You can also drop a JSON/CSV file anywhere to import)</span>
  </div>
  <div class="row">
    <label>Go to frame: <input id="gotoFrameInput" type="number" min="0" style="width:120px"></label>
    <button id="gotoFrameBtn">Go</button>
    <button id="firstFrameBtn">First Frame</button>
  </div>
  <div class="row">
    <input id="scrubSlider" type="range" min="0" value="0" step="1" style="flex:1; max-width:520px" disabled>
    <label>Time: <span id="currentTime">0:00.000</span> / <span id="totalTime">0:00.000</span></label>
  </div>

  <div id="player">
    <div>
  <video id="video" crossorigin="anonymous" playsinline style="display:none; width:0; height:0;"></video>
  <canvas id="canvas"></canvas>
      <div class="row">
        <button id="prevBtn">◀ Prev</button>
        <button id="nextBtn">Next ▶</button>
        <button id="playPauseBtn">Play</button>
        <label>Frame: <span id="frameIndex">0</span>/<span id="frameCount">0</span></label>
      </div>
      <div class="row">
        <label>Current frame markers: <span id="markerCount">0</span></label>
        <span class="hint">(use slider or mouse wheel to scrub; click/drag to add, shift+click to remove nearest)</span>
      </div>
    </div>

    <div class="controls">
      <div><strong>Markers per frame</strong></div>
      <div id="pointsList">No frame loaded.</div>
      <div id="tagMappingContainer" style="margin-top:10px;">
        <button id="toggleTagMap" style="padding:6px 8px;">Tags ▼</button>
        <div id="tagMapList" style="display:none; margin-top:8px; border:1px solid #eee; padding:8px; background:#fff;"></div>
      </div>
    </div>
  </div>

  <script>
  // Minimal, standalone video frame annotator tool.
  const fileInput = document.getElementById('fileInput');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const playPauseBtn = document.getElementById('playPauseBtn');
  const frameIndexLabel = document.getElementById('frameIndex');
  const frameCountLabel = document.getElementById('frameCount');
  const markerCountLabel = document.getElementById('markerCount');
  const pointsList = document.getElementById('pointsList');
  const exportBtn = document.getElementById('exportBtn');
  const clearBtn = document.getElementById('clearBtn');
  const frameStepInput = document.getElementById('frameStepInput');
  const exportFormat = document.getElementById('exportFormat');
  const exportFormatCsv = document.getElementById('exportFormatCsv');
  const fpsInput = document.getElementById('fpsInput');
  const fpsWarn = document.getElementById('fpsWarn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const gotoFrameInput = document.getElementById('gotoFrameInput');
  const gotoFrameBtn = document.getElementById('gotoFrameBtn');
  const firstFrameBtn = document.getElementById('firstFrameBtn');
  const modePoint = document.getElementById('modePoint');
  const modeBox = document.getElementById('modeBox');
  const modeCircle = document.getElementById('modeCircle');
  const importInput = document.getElementById('importInput');
  const importBtn = document.getElementById('importBtn');
  const scrubSlider = document.getElementById('scrubSlider');
  const currentTimeLabel = document.getElementById('currentTime');
  const totalTimeLabel = document.getElementById('totalTime');

  // Data structure: map frameNumber -> array of markers
  // Each marker: {type:'point', x, y} OR {type:'box', x1, y1, x2, y2} OR {type:'circle', cx, cy, radius} OR {type:'square', cx, cy, radius}
  const markers = {};
  let detectedFPS = null; // will hold detected fps when available
  let uploadedFilename = null;

  // Undo/redo stacks: store simple operations {type:'add'|'remove'|'clear-frame'|'clear-all', frame, point, prevState}
  const undoStack = [];
  const redoStack = [];

  // Tagging and color support
  // tagMap: { [tag]: { tag_name: string, color: {r,g,b,a} } }
  const tagMap = {};
  let tagCounter = 0;
  let lastKeyPressed = null; // stores last alnum key while mouse down
  const DEFAULT_ALPHA = 0.7;

  function hashStringToHue(s) {
    let h = 0;
    for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) % 360;
    return h;
  }

  function hslToRgb(h, s, l) {
    // h in [0,360], s,l in [0,1]
    h /= 360;
    let r, g, b;
    if (s === 0) r = g = b = l;
    else {
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
  }

  function rgbToHex(r,g,b){
    const toHex = (n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2,'0');
    return '#'+toHex(r)+toHex(g)+toHex(b);
  }

  function hexToRgb(hex){
    if (!hex) return null;
    hex = String(hex).replace('#','');
    if (hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
    const v = parseInt(hex,16);
    if (!isFinite(v)) return null;
    return { r: (v>>16)&255, g: (v>>8)&255, b: v&255 };
  }

  function assignColorForTag(tag) {
    // Use golden-angle spacing to pick distinct hues for successive tags,
    // then add a small offset based on the tag hash so the mapping is deterministic
    const GOLDEN_ANGLE = 137.508; // degrees
    const base = (tagCounter * GOLDEN_ANGLE) % 360;
    const offset = hashStringToHue(tag) % 25; // small deterministic perturbation
    const hue = (base + offset) % 360;
    tagCounter = (tagCounter + 1) % 3600;
    const rgb = hslToRgb(hue, 0.85, 0.45);
    return { r: rgb.r, g: rgb.g, b: rgb.b, a: DEFAULT_ALPHA };
  }

  function attachTagAndColor(marker) {
    if (!marker) return;
    if (lastKeyPressed && /^[A-Za-z0-9]$/.test(lastKeyPressed)) {
      const tag = String(lastKeyPressed); // preserve case sensitivity for tag keys
      marker.tag = tag;
      if (!tagMap[tag]) tagMap[tag] = { tag_name: tag, color: assignColorForTag(tag) };
      const c = tagMap[tag].color;
      marker.r = Number.isFinite(marker.r) ? marker.r : c.r;
      marker.g = Number.isFinite(marker.g) ? marker.g : c.g;
      marker.b = Number.isFinite(marker.b) ? marker.b : c.b;
      marker.a = Number.isFinite(marker.a) ? marker.a : c.a;
    } else {
      // default green
      marker.r = Number.isFinite(marker.r) ? marker.r : 0;
      marker.g = Number.isFinite(marker.g) ? marker.g : 255;
      marker.b = Number.isFinite(marker.b) ? marker.b : 0;
      marker.a = Number.isFinite(marker.a) ? marker.a : DEFAULT_ALPHA;
    }
    updateTagMappingUI();
  }

  let rafId = null;
  let playing = false;
  let isScrubbing = false;
  let wasPlayingOnScrub = false;

  // Drawing state for drag operations
  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragCurrentX = 0;
  let dragCurrentY = 0;

  function resetCanvasSize() {
    const w = video.videoWidth;
    const h = video.videoHeight;
    if (!w || !h) return;
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = Math.min(w, window.innerWidth*0.75) + 'px';
    canvas.style.height = (canvas.height * (parseInt(canvas.style.width)/canvas.width)) + 'px';
  }

  function drawFrameOverlay() {
    if (!video.videoWidth) return;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // draw current video frame into canvas
    try {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    } catch(e) {
      // drawImage may fail if video not ready
    }

    // draw markers for current frame
    const frame = getCurrentFrameIndex();
    const arr = markers[frame] || [];
    for (let i = 0; i < arr.length; i++) {
      const m = arr[i];
      drawMarker(m, i+1);
    }

    // draw drag preview if dragging
    if (isDragging) {
      drawDragPreview();
    }

    markerCountLabel.textContent = arr.length;
    renderPointsList(frame, arr);
  }

  function drawMarker(marker, index) {
    ctx.save();
    ctx.lineWidth = 2;
    // color from marker or defaults
    const mr = (marker && Number.isFinite(marker.r)) ? marker.r : 0;
    const mg = (marker && Number.isFinite(marker.g)) ? marker.g : 255;
    const mb = (marker && Number.isFinite(marker.b)) ? marker.b : 0;
    const ma = (marker && Number.isFinite(marker.a)) ? marker.a : DEFAULT_ALPHA;
    const strokeCss = `rgba(${mr},${mg},${mb},${ma})`;
    const fillCss = `rgba(${mr},${mg},${mb},${Math.max(0.12, ma*0.35)})`;

    ctx.strokeStyle = strokeCss;
    ctx.fillStyle = fillCss;

    if (!marker.type || marker.type === 'point') {
      // Draw point marker
      ctx.beginPath();
      ctx.arc(marker.x, marker.y, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = 'black';
      ctx.font = '12px sans-serif';
      ctx.fillText(String(index), marker.x+8, marker.y+4);
    } else if (marker.type === 'box') {
      // Draw bounding box
      const x = Math.min(marker.x1, marker.x2);
      const y = Math.min(marker.y1, marker.y2);
      const w = Math.abs(marker.x2 - marker.x1);
      const h = Math.abs(marker.y2 - marker.y1);
      ctx.fillRect(x, y, w, h);
      ctx.strokeRect(x, y, w, h);
      ctx.fillStyle = strokeCss;
      ctx.font = '12px sans-serif';
      ctx.fillText(String(index), x+4, y+14);
    } else if (marker.type === 'circle') {
      // Draw circle
      ctx.beginPath();
      ctx.arc(marker.cx, marker.cy, marker.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = strokeCss;
      ctx.font = '12px sans-serif';
      ctx.fillText(String(index), marker.cx+marker.radius+4, marker.cy);
    } else if (marker.type === 'square') {
      // Draw centered square: radius is half-side
      const r = Number(marker.radius) || 0;
      const x = (marker.cx || marker.x) - r;
      const y = (marker.cy || marker.y) - r;
      const side = r * 2;
      ctx.fillRect(x, y, side, side);
      ctx.strokeRect(x, y, side, side);
      ctx.fillStyle = strokeCss;
      ctx.font = '12px sans-serif';
      ctx.fillText(String(index), (marker.cx || marker.x) + r + 4, (marker.cy || marker.y));
    }

    ctx.restore();
  }

  function drawDragPreview() {
    ctx.save();
    ctx.strokeStyle = 'yellow';
    ctx.fillStyle = 'rgba(255,255,0,0.2)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);

    const mode = document.querySelector('input[name="annotationMode"]:checked').value;
    if (mode === 'box') {
      const x = Math.min(dragStartX, dragCurrentX);
      const y = Math.min(dragStartY, dragCurrentY);
      const w = Math.abs(dragCurrentX - dragStartX);
      const h = Math.abs(dragCurrentY - dragStartY);
      ctx.fillRect(x, y, w, h);
      ctx.strokeRect(x, y, w, h);
    } else if (mode === 'circle') {
      const radius = Math.hypot(dragCurrentX - dragStartX, dragCurrentY - dragStartY);
      ctx.beginPath();
      ctx.arc(dragStartX, dragStartY, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    } else if (mode === 'square') {
      const radius = Math.hypot(dragCurrentX - dragStartX, dragCurrentY - dragStartY);
      const side = radius * 2;
      const x = dragStartX - radius;
      const y = dragStartY - radius;
      ctx.fillRect(x, y, side, side);
      ctx.strokeRect(x, y, side, side);
    }

    ctx.restore();
  }

  function renderPointsList(frame, arr) {
    pointsList.innerHTML = '';
    const title = document.createElement('div');
    title.textContent = 'Frame ' + frame + ' — ' + arr.length + ' marker(s)';
    title.style.fontWeight = '600';
    title.style.marginBottom = '6px';
    pointsList.appendChild(title);
    if (arr.length === 0) {
      const note = document.createElement('div');
      note.textContent = 'No markers for this frame.';
      pointsList.appendChild(note);
      return;
    }
    arr.forEach((m, i) => {
      const d = document.createElement('div');
      d.className = 'point-item';
      // show color swatch and tag name if present
      const sw = document.createElement('span');
      const rr = Number.isFinite(m.r) ? m.r : 0;
      const gg = Number.isFinite(m.g) ? m.g : 255;
      const bb = Number.isFinite(m.b) ? m.b : 0;
      sw.style.display = 'inline-block';
      sw.style.width = '12px'; sw.style.height = '12px';
      sw.style.marginRight = '8px';
      sw.style.verticalAlign = 'middle';
      sw.style.background = `rgba(${rr},${gg},${bb},${Number.isFinite(m.a)?m.a:DEFAULT_ALPHA})`;
      d.appendChild(sw);
      if (!m.type || m.type === 'point') {
        d.appendChild(document.createTextNode(`${i+1}: Point (${Math.round(m.x)}, ${Math.round(m.y)})`));
      } else if (m.type === 'box') {
        d.appendChild(document.createTextNode(`${i+1}: Box (${Math.round(m.x1)}, ${Math.round(m.y1)}) to (${Math.round(m.x2)}, ${Math.round(m.y2)})`));
      } else if (m.type === 'circle') {
        d.appendChild(document.createTextNode(`${i+1}: Circle center (${Math.round(m.cx)}, ${Math.round(m.cy)}) radius ${Math.round(m.radius)}`));
      } else if (m.type === 'square') {
        d.appendChild(document.createTextNode(`${i+1}: Square center (${Math.round(m.cx||m.x)}, ${Math.round(m.cy||m.y)}) half-side ${Math.round(m.radius)}`));
      }
      if (m.tag) {
        const tn = (tagMap[m.tag] && tagMap[m.tag].tag_name) ? tagMap[m.tag].tag_name : m.tag;
        const tagSpan = document.createElement('span');
        tagSpan.style.marginLeft = '8px';
        tagSpan.style.fontWeight = '600';
        tagSpan.textContent = `[${m.tag}: ${tn}]`;
        d.appendChild(tagSpan);
      }
      pointsList.appendChild(d);
    });
  }

  // Convert video currentTime to frame index (integer)
  function getCurrentFrameIndex() {
    const fps = estimateFPS();
    const frame = Math.round(video.currentTime * fps);
    return frame;
  }

  // Heuristic to estimate fps from media (some videos don't expose fps); fallback to 25
  function estimateFPS() {
    // Prefer user-entered FPS, then detectedFPS, otherwise fallback to 25
    const user = parseFloat(fpsInput.value);
    if (isFinite(user) && user > 0) return user;
    if (detectedFPS && isFinite(detectedFPS) && detectedFPS > 0) return detectedFPS;
    const defaultFPS = 25;
    // Try to infer from video.getVideoPlaybackQuality() if available (best-effort)
    try {
      if (video.getVideoPlaybackQuality) {
        const q = video.getVideoPlaybackQuality();
        if (q && q.totalVideoFrames && video.duration) {
          const guessed = q.totalVideoFrames / video.duration;
          if (isFinite(guessed) && guessed > 1 && guessed < 1000) return Math.round(guessed);
        }
      }
    } catch(e) {}
    return defaultFPS;
  }

  // Seek to a specific frame index
  function seekToFrame(frameIndex) {
    const fps = estimateFPS();
    video.currentTime = frameIndex / fps;
  }

  function updateFrameLabels() {
    const fps = estimateFPS();
    const totalFrames = Math.max(0, Math.round(video.duration * fps));
    frameCountLabel.textContent = totalFrames;
    frameIndexLabel.textContent = getCurrentFrameIndex();
    // Update scrub slider and time labels
    if (Number.isFinite(video.duration)) {
      totalTimeLabel.textContent = formatTime(video.duration);
    } else {
      totalTimeLabel.textContent = '0:00.000';
    }
    currentTimeLabel.textContent = formatTime(video.currentTime || 0);
    const maxFrame = Math.max(0, totalFrames - 1);
    if (scrubSlider) {
      scrubSlider.max = String(maxFrame);
      scrubSlider.step = '1';
      scrubSlider.disabled = !(video.readyState >= 1);
      if (!isScrubbing) {
        const cf = getCurrentFrameIndex();
        scrubSlider.value = String(Math.min(Math.max(0, cf), maxFrame));
      }
    }
  }

  function formatTime(sec) {
    if (!Number.isFinite(sec) || sec < 0) sec = 0;
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    const ms = Math.floor((sec - Math.floor(sec)) * 1000);
    return `${m}:${String(s).padStart(2,'0')}.${String(ms).padStart(3,'0')}`;
  }

  // Navigation
  prevBtn.addEventListener('click', () => {
    const step = parseInt(frameStepInput.value) || 1;
    const idx = getCurrentFrameIndex() - step;
    seekToFrame(Math.max(0, idx));
  });
  nextBtn.addEventListener('click', () => {
    const step = parseInt(frameStepInput.value) || 1;
    const idx = getCurrentFrameIndex() + step;
    seekToFrame(Math.max(0, idx));
  });

  playPauseBtn.addEventListener('click', () => {
    if (playing) { video.pause(); } else { video.play(); }
  });

  video.addEventListener('play', () => { playing = true; playPauseBtn.textContent = 'Pause'; tick(); });
  video.addEventListener('pause', () => { playing = false; playPauseBtn.textContent = 'Play'; cancelAnimationFrame(rafId); });

  function tick() {
    drawFrameOverlay();
    updateFrameLabels();
    rafId = requestAnimationFrame(tick);
  }

  // When seeking completes, redraw overlay
  video.addEventListener('seeked', () => {
    drawFrameOverlay();
    updateFrameLabels();
  });

  // Scrubbing interactions
  if (scrubSlider) {
    scrubSlider.addEventListener('pointerdown', () => {
      wasPlayingOnScrub = playing;
      if (playing) video.pause();
      isScrubbing = true;
    });
    scrubSlider.addEventListener('input', () => {
      const f = parseInt(scrubSlider.value) || 0;
      seekToFrame(f);
      drawFrameOverlay();
      updateFrameLabels();
    });
    const endScrub = () => {
      if (!isScrubbing) return;
      isScrubbing = false;
      if (wasPlayingOnScrub) video.play();
    };
    scrubSlider.addEventListener('pointerup', endScrub);
    scrubSlider.addEventListener('pointercancel', endScrub);
    scrubSlider.addEventListener('change', () => {
      // Ensure final position applied
      const f = parseInt(scrubSlider.value) || 0;
      seekToFrame(f);
      drawFrameOverlay();
      updateFrameLabels();
      endScrub();
    });
  }

  // File input
  fileInput.addEventListener('change', (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    uploadedFilename = file.name;
    const url = URL.createObjectURL(file);
    video.src = url;
    video.load();
    video.addEventListener('loadedmetadata', () => {
      resetCanvasSize();
      // Attempt to read FPS from file metadata if available via mediaTracks (some browsers expose frameRate)
      detectedFPS = null;
      try {
        const tracks = video.webkitVideoDecodedByteCount !== undefined ? video.webkitDecodedFrameCount : null;
      } catch(e) {}
      // Some browsers expose frameRate on the first video track via mediaStreamTrack.getSettings (rare on local files)
      // We'll also try to probe playback quality after a short play to populate totalVideoFrames
      drawFrameOverlay();
      updateFrameLabels();
      // quick probe: play briefly muted to let getVideoPlaybackQuality gather frames
      const probe = async () => {
        try {
          video.muted = true;
          await video.play();
          await new Promise(r => setTimeout(r, 200));
          video.pause();
          video.muted = false;
          // try to compute fps from playbackQuality
          if (video.getVideoPlaybackQuality) {
            const q = video.getVideoPlaybackQuality();
            if (q && q.totalVideoFrames && video.duration) {
              const guessed = q.totalVideoFrames / video.duration;
              if (isFinite(guessed) && guessed > 1 && guessed < 1000) detectedFPS = Math.round(guessed);
            }
          }
        } catch(e) {
          // ignore probe errors
        }
        updateFrameLabels();
        drawFrameOverlay();
        // reflect detectedFPS in UI
        if (detectedFPS) { fpsInput.value = detectedFPS; fpsWarn.style.visibility = 'visible'; }
      };
      probe();
    }, { once: true });
  });

  // Drag & drop support for the whole document
  ['dragenter','dragover'].forEach(evt => document.addEventListener(evt, (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; }));
  document.addEventListener('drop', (e) => {
    e.preventDefault();
    const files = Array.from(e.dataTransfer.files || []);
    if (!files.length) return;

    // Handle video files (first one)
    const videoFile = files.find(file => file.type.startsWith('video/') || /\.(mp4|mov|avi|webm|mkv)$/i.test(file.name));
    if (videoFile) {
      fileInput.files = e.dataTransfer.files; // keep default behavior
      uploadedFilename = videoFile.name;
      const url = URL.createObjectURL(videoFile);
      video.src = url;
      video.load();
      video.addEventListener('loadedmetadata', () => { resetCanvasSize(); drawFrameOverlay(); updateFrameLabels(); }, { once: true });
    }

    // Handle annotation files (all .json/.csv)
    const annoFiles = files.filter(file => /\.(json|csv)$/i.test(file.name) || /json|csv/.test(file.type));
    if (annoFiles.length) {
      const replace = confirm('Import annotations from dropped file(s). Replace existing annotations?\nOK = Replace, Cancel = Merge');
      annoFiles.forEach(f => importAnnotationsFile(f, replace));
    }
  });

  // Import controls
  importBtn.addEventListener('click', () => {
    if (importInput.files && importInput.files[0]) {
      const file = importInput.files[0];
      const replace = confirm('Replace existing annotations?\nOK = Replace, Cancel = Merge');
      importAnnotationsFile(file, replace);
    } else {
      alert('Please choose a JSON or CSV file to import.');
    }
  });

  function importAnnotationsFile(file, replace) {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const name = file.name.toLowerCase();
        if (name.endsWith('.json')) {
          const text = reader.result;
          loadAnnotationsFromJsonText(String(text), replace);
        } else if (name.endsWith('.csv')) {
          const text = reader.result;
          loadAnnotationsFromCsvText(String(text), replace);
        } else if (/json/.test(file.type)) {
          const text = reader.result;
          loadAnnotationsFromJsonText(String(text), replace);
        } else if (/csv/.test(file.type) || name.includes('.csv')) {
          const text = reader.result;
          loadAnnotationsFromCsvText(String(text), replace);
        } else {
          alert('Unsupported annotation file: ' + file.name);
        }
      } catch(err) {
        console.error('Import failed', err);
        alert('Failed to import annotations: ' + err.message);
      }
    };
    reader.onerror = () => alert('Failed to read file: ' + file.name);
    reader.readAsText(file);
  }

  function loadAnnotationsFromJsonText(text, replace) {
    const data = JSON.parse(text);
    // Accept multiple shapes
    // 1) { meta, markers: [ { frame, time, markers: [ {type,...} ] } ] }
    // 2) [ { frame, time, points: [ {x,y} ] } ] -> convert to type 'point'
    // 3) { [frame]: [ {x,y} ] } -> convert to type 'point'

    const incoming = {};
    if (Array.isArray(data)) {
      data.forEach(fr => {
        const frame = Math.round(Number(fr.frame));
        if (!isFinite(frame)) return;
        if (!incoming[frame]) incoming[frame] = [];
        const arr = fr.markers || fr.points || [];
        arr.forEach(m => {
          incoming[frame].push(normalizeMarker(m));
        });
      });
    } else if (data && Array.isArray(data.markers)) {
      data.markers.forEach(fr => {
        const frame = Math.round(Number(fr.frame));
        if (!isFinite(frame)) return;
        if (!incoming[frame]) incoming[frame] = [];
        const arr = fr.markers || fr.points || [];
        arr.forEach(m => {
          incoming[frame].push(normalizeMarker(m));
        });
      });
      // If FPS exists in meta, set it (hint only)
      if (data.meta && data.meta.fps && isFinite(data.meta.fps)) {
        fpsInput.value = Number(data.meta.fps);
      }
    } else if (data && typeof data === 'object') {
      Object.keys(data).forEach(k => {
        const frame = Math.round(Number(k));
        if (!isFinite(frame)) return;
        if (!incoming[frame]) incoming[frame] = [];
        const arr = data[k] || [];
        arr.forEach(m => incoming[frame].push(normalizeMarker(m)));
      });
    }

    applyImportedMarkers(incoming, replace);
  }

  function loadAnnotationsFromCsvText(text, replace) {
    const lines = String(text).split(/\r?\n/).filter(l => l.trim().length);
    if (!lines.length) return;
    const header = lines[0].split(',').map(s => s.trim());
    const rows = lines.slice(1);
    const incoming = {};

    // Detect format: new has 'type' in header; old has 'point_index' without 'type'
  const idx = (name) => header.indexOf(name);
  const hasType = idx('type') !== -1;
  // support alternative px/py column names when x/y are missing
  const xIndexFallback = idx('x') !== -1 ? idx('x') : idx('px');
  const yIndexFallback = idx('y') !== -1 ? idx('y') : idx('py');
  // color and tag indices (available for both formats if present)
  const rIdxAny = idx('r') !== -1 ? idx('r') : idx('red');
  const gIdxAny = idx('g') !== -1 ? idx('g') : idx('green');
  const bIdxAny = idx('b') !== -1 ? idx('b') : idx('blue');
  const aIdxAny = idx('a') !== -1 ? idx('a') : idx('alpha');
  const tagIdxAny = idx('tag') !== -1 ? idx('tag') : idx('label');
  const tagNameIdxAny = idx('tag_name') !== -1 ? idx('tag_name') : -1;

    if (hasType) {
      const fi = idx('frame');
      const ti = idx('time_seconds');
      const mi = idx('marker_index');
      const ty = idx('type');
  const x = idx('x');
  const y = idx('y');
  const x1 = idx('x1');
  const y1 = idx('y1');
  const x2 = idx('x2');
  const y2 = idx('y2');
  const cx = idx('cx');
  const cy = idx('cy');
  const rad = idx('radius');
      const rIdx = idx('r') !== -1 ? idx('r') : idx('red');
      const gIdx = idx('g') !== -1 ? idx('g') : idx('green');
      const bIdx = idx('b') !== -1 ? idx('b') : idx('blue');
      const aIdx = idx('a') !== -1 ? idx('a') : idx('alpha');
  const tagIdx = idx('tag') !== -1 ? idx('tag') : idx('label');
  const tagNameIdx = idx('tag_name') !== -1 ? idx('tag_name') : -1;
      rows.forEach(line => {
        const cols = line.split(',');
        const frame = Math.round(Number(cols[fi]));
        if (!isFinite(frame)) return;
        const type = (cols[ty] || 'point').trim();
        if (!incoming[frame]) incoming[frame] = [];
        if (type === 'point') {
          const xi = (x !== -1) ? x : xIndexFallback;
          const yi = (y !== -1) ? y : yIndexFallback;
          const m = { type: 'point', x: num(cols[xi]), y: num(cols[yi]) };
          if (rIdx !== -1) m.r = num(cols[rIdx]);
          if (gIdx !== -1) m.g = num(cols[gIdx]);
          if (bIdx !== -1) m.b = num(cols[bIdx]);
          m.a = (aIdx !== -1 && cols[aIdx] !== undefined && cols[aIdx] !== '') ? Number(cols[aIdx]) : DEFAULT_ALPHA;
          if (tagIdx !== -1 && cols[tagIdx]) m.tag = cols[tagIdx];
          if (tagNameIdx !== -1 && cols[tagNameIdx]) m.tag_name = cols[tagNameIdx];
          incoming[frame].push(m);
        } else if (type === 'box') {
          // Prefer explicit x1/y1 columns if present, fallback to x/y
          const x1i = (x1 !== -1) ? x1 : x;
          const y1i = (y1 !== -1) ? y1 : y;
          const m = { type: 'box', x1: num(cols[x1i]), y1: num(cols[y1i]), x2: num(cols[x2]), y2: num(cols[y2]) };
          if (rIdx !== -1) m.r = num(cols[rIdx]);
          if (gIdx !== -1) m.g = num(cols[gIdx]);
          if (bIdx !== -1) m.b = num(cols[bIdx]);
          m.a = (aIdx !== -1 && cols[aIdx] !== undefined && cols[aIdx] !== '') ? Number(cols[aIdx]) : DEFAULT_ALPHA;
          if (tagIdx !== -1 && cols[tagIdx]) m.tag = cols[tagIdx];
          if (tagNameIdx !== -1 && cols[tagNameIdx]) m.tag_name = cols[tagNameIdx];
          incoming[frame].push(m);
        } else if (type === 'circle') {
          // Circle centers may be exported into x,y (preferred) or cx,cy (legacy); also accept px/py
          const centerXIndex = (x !== -1) ? x : ((cx !== -1) ? cx : xIndexFallback);
          const centerYIndex = (y !== -1) ? y : ((cy !== -1) ? cy : yIndexFallback);
          const m = { type: 'circle', cx: num(cols[centerXIndex]), cy: num(cols[centerYIndex]), radius: num(cols[rad]) };
          if (rIdx !== -1) m.r = num(cols[rIdx]);
          if (gIdx !== -1) m.g = num(cols[gIdx]);
          if (bIdx !== -1) m.b = num(cols[bIdx]);
          m.a = (aIdx !== -1 && cols[aIdx] !== undefined && cols[aIdx] !== '') ? Number(cols[aIdx]) : DEFAULT_ALPHA;
          if (tagIdx !== -1 && cols[tagIdx]) m.tag = cols[tagIdx];
          if (tagNameIdx !== -1 && cols[tagNameIdx]) m.tag_name = cols[tagNameIdx];
          incoming[frame].push(m);
        } else if (type === 'square') {
          // Square: center in x,y (or cx,cy) and radius is half-side
          const centerXIndexS = (x !== -1) ? x : ((cx !== -1) ? cx : xIndexFallback);
          const centerYIndexS = (y !== -1) ? y : ((cy !== -1) ? cy : yIndexFallback);
          const ms = { type: 'square', cx: num(cols[centerXIndexS]), cy: num(cols[centerYIndexS]), radius: num(cols[rad]) };
          if (rIdx !== -1) ms.r = num(cols[rIdx]);
          if (gIdx !== -1) ms.g = num(cols[gIdx]);
          if (bIdx !== -1) ms.b = num(cols[bIdx]);
          ms.a = (aIdx !== -1 && cols[aIdx] !== undefined && cols[aIdx] !== '') ? Number(cols[aIdx]) : DEFAULT_ALPHA;
          if (tagIdx !== -1 && cols[tagIdx]) ms.tag = cols[tagIdx];
          if (tagNameIdx !== -1 && cols[tagNameIdx]) ms.tag_name = cols[tagNameIdx];
          incoming[frame].push(ms);
        }
      });
    } else {
      // Old format: frame,time_seconds,point_index,x,y
      const fi = idx('frame');
      const x = idx('x') !== -1 ? idx('x') : idx('px');
      const y = idx('y') !== -1 ? idx('y') : idx('py');
      rows.forEach(line => {
        const cols = line.split(',');
        const frame = Math.round(Number(cols[fi]));
        if (!isFinite(frame)) return;
        if (!incoming[frame]) incoming[frame] = [];
        const m = { type: 'point', x: num(cols[x]), y: num(cols[y]) };
        if (rIdxAny !== -1) m.r = num(cols[rIdxAny]);
        if (gIdxAny !== -1) m.g = num(cols[gIdxAny]);
        if (bIdxAny !== -1) m.b = num(cols[bIdxAny]);
        m.a = (aIdxAny !== -1 && cols[aIdxAny] !== undefined && cols[aIdxAny] !== '') ? Number(cols[aIdxAny]) : DEFAULT_ALPHA;
        if (tagIdxAny !== -1 && cols[tagIdxAny]) m.tag = cols[tagIdxAny];
        if (tagNameIdxAny !== -1 && cols[tagNameIdxAny]) m.tag_name = cols[tagNameIdxAny];
        incoming[frame].push(m);
      });
    }

    applyImportedMarkers(incoming, replace);
  }

  function num(v) { const n = Number(v); return isFinite(n) ? Math.round(n) : 0; }

  function normalizeMarker(m) {
    if (!m) return null;
    if (!m.type) {
      // accept alternative px/py fields when x/y missing
      const xVal = (isFinite(m.x) ? m.x : (isFinite(m.px) ? m.px : undefined));
      const yVal = (isFinite(m.y) ? m.y : (isFinite(m.py) ? m.py : undefined));
      if (isFinite(xVal) && isFinite(yVal)) return { type: 'point', x: num(xVal), y: num(yVal) };
      // otherwise ignore
      return null;
    }
    if (m.type === 'point') {
      const xVal = (isFinite(m.x) ? m.x : (isFinite(m.px) ? m.px : undefined));
      const yVal = (isFinite(m.y) ? m.y : (isFinite(m.py) ? m.py : undefined));
      const point = { type: 'point', x: num(xVal), y: num(yVal) };
      // color and tag support
      if (isFinite(m.r)) point.r = num(m.r);
      if (isFinite(m.g)) point.g = num(m.g);
      if (isFinite(m.b)) point.b = num(m.b);
      point.a = isFinite(m.a) ? Number(m.a) : DEFAULT_ALPHA;
      if (m.tag) point.tag = String(m.tag);
      if (m.tag_name) point.tag_name = String(m.tag_name);
      return point;
    }
    if (m.type === 'box') {
      // Accept explicit x1/y1 or legacy x/y/px/py for the first corner
      const x1v = (isFinite(m.x1) ? m.x1 : (isFinite(m.x) ? m.x : (isFinite(m.px) ? m.px : undefined)));
      const y1v = (isFinite(m.y1) ? m.y1 : (isFinite(m.y) ? m.y : (isFinite(m.py) ? m.py : undefined)));
      const box = { type: 'box', x1: num(x1v), y1: num(y1v), x2: num(m.x2), y2: num(m.y2) };
      // preserve explicit color if present
      if (isFinite(m.r)) box.r = num(m.r);
      if (isFinite(m.g)) box.g = num(m.g);
      if (isFinite(m.b)) box.b = num(m.b);
      box.a = isFinite(m.a) ? Number(m.a) : DEFAULT_ALPHA;
      if (m.tag) box.tag = String(m.tag);
      if (m.tag_name) box.tag_name = String(m.tag_name);
      return box;
    }
    if (m.type === 'circle') {
      // accept either cx/cy or x/y (or px/py) in imported data
      const cxv = (isFinite(m.cx) ? m.cx : (isFinite(m.x) ? m.x : (isFinite(m.px) ? m.px : undefined)));
      const cyv = (isFinite(m.cy) ? m.cy : (isFinite(m.y) ? m.y : (isFinite(m.py) ? m.py : undefined)));
      const c = { type: 'circle', cx: num(cxv), cy: num(cyv), radius: num(m.radius) };
      if (isFinite(m.r)) c.r = num(m.r);
      if (isFinite(m.g)) c.g = num(m.g);
      if (isFinite(m.b)) c.b = num(m.b);
      c.a = isFinite(m.a) ? Number(m.a) : DEFAULT_ALPHA;
      if (m.tag) c.tag = String(m.tag);
      if (m.tag_name) c.tag_name = String(m.tag_name);
      return c;
    }
    if (m.type === 'square') {
      // accept either cx/cy or x/y (or px/py) in imported data
      const cxv = (isFinite(m.cx) ? m.cx : (isFinite(m.x) ? m.x : (isFinite(m.px) ? m.px : undefined)));
      const cyv = (isFinite(m.cy) ? m.cy : (isFinite(m.y) ? m.y : (isFinite(m.py) ? m.py : undefined)));
      const s = { type: 'square', cx: num(cxv), cy: num(cyv), radius: num(m.radius) };
      if (isFinite(m.r)) s.r = num(m.r);
      if (isFinite(m.g)) s.g = num(m.g);
      if (isFinite(m.b)) s.b = num(m.b);
      s.a = isFinite(m.a) ? Number(m.a) : DEFAULT_ALPHA;
      if (m.tag) s.tag = String(m.tag);
      if (m.tag_name) s.tag_name = String(m.tag_name);
      return s;
    }
    return null;
  }

  function applyImportedMarkers(incoming, replace) {
    if (replace) {
      for (const k in markers) delete markers[k];
    }
    Object.keys(incoming).forEach(k => {
      const frame = Number(k);
      if (!markers[frame]) markers[frame] = [];
      incoming[frame].forEach(m => {
        if (!m) return;
        // ensure color and tag mapping
        if (m.tag) {
          const tag = String(m.tag);
          if (!tagMap[tag]) {
            tagMap[tag] = { tag_name: tag, color: assignColorForTag(tag) };
          }
          // If incoming marker provided a human-readable tag_name, preserve it
          if (m.tag_name) tagMap[tag].tag_name = String(m.tag_name);
          const c = tagMap[tag].color;
          if (!Number.isFinite(m.r)) m.r = c.r;
          if (!Number.isFinite(m.g)) m.g = c.g;
          if (!Number.isFinite(m.b)) m.b = c.b;
          m.a = Number.isFinite(m.a) ? m.a : c.a;
        } else {
          // assign default green color if none provided
          if (!Number.isFinite(m.r)) m.r = 0;
          if (!Number.isFinite(m.g)) m.g = 255;
          if (!Number.isFinite(m.b)) m.b = 0;
          m.a = Number.isFinite(m.a) ? m.a : DEFAULT_ALPHA;
        }
        markers[frame].push(m);
      });
    });
    drawFrameOverlay();
    updateFrameLabels();
    updateTagMappingUI();
  }

  // Canvas mouse handlers for drawing markers
  function getCanvasCoords(ev) {
    const rect = canvas.getBoundingClientRect();
    const cssX = ev.clientX - rect.left;
    const cssY = ev.clientY - rect.top;
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return { x: cssX * scaleX, y: cssY * scaleY };
  }

  canvas.addEventListener('mousedown', (ev) => {
    if (!video.videoWidth || !video.videoHeight) return;
    const coords = getCanvasCoords(ev);
    const frame = getCurrentFrameIndex();

    if (ev.shiftKey) {
      // remove nearest marker within threshold
      const arr = markers[frame] || [];
      if (arr.length === 0) return;
      let bestIdx = -1; let bestDist = Infinity;
      for (let i=0; i<arr.length; i++){
        const m = arr[i];
        let d = Infinity;
        if (!m.type || m.type === 'point') {
          d = Math.hypot(m.x - coords.x, m.y - coords.y);
        } else if (m.type === 'box') {
          // distance to box center
          const cx = (m.x1 + m.x2) / 2;
          const cy = (m.y1 + m.y2) / 2;
          d = Math.hypot(cx - coords.x, cy - coords.y);
        } else if (m.type === 'circle' || m.type === 'square') {
          // For both circle and square use center distance for proximity tests
          const cx = (m.cx !== undefined) ? m.cx : m.x;
          const cy = (m.cy !== undefined) ? m.cy : m.y;
          d = Math.hypot(cx - coords.x, cy - coords.y);
        }
        if (d < bestDist) { bestDist = d; bestIdx = i; }
      }
      if (bestDist < 30) {
        const removed = arr.splice(bestIdx, 1)[0]; 
        markers[frame] = arr;
        undoStack.push({ type: 'remove', frame, point: removed }); 
        redoStack.length = 0;
        drawFrameOverlay();
      }
      return;
    }

    // Start drag
    isDragging = true;
    dragStartX = coords.x;
    dragStartY = coords.y;
    dragCurrentX = coords.x;
    dragCurrentY = coords.y;
  });

  // Mouse wheel scrubbing over canvas: step frames up/down
  canvas.addEventListener('wheel', (e) => {
    if (!video.videoWidth) return;
    e.preventDefault();
    const step = parseInt(frameStepInput.value) || 1;
    const delta = Math.sign(e.deltaY);
    let idx = getCurrentFrameIndex() + (delta > 0 ? step : -step);
    idx = Math.max(0, idx);
    seekToFrame(idx);
  }, { passive: false });

  canvas.addEventListener('mousemove', (ev) => {
    if (!isDragging) return;
    const coords = getCanvasCoords(ev);
    dragCurrentX = coords.x;
    dragCurrentY = coords.y;
    drawFrameOverlay();
  });

  canvas.addEventListener('mouseup', (ev) => {
    if (!isDragging) return;
    isDragging = false;

    const coords = getCanvasCoords(ev);
    const frame = getCurrentFrameIndex();
    const mode = document.querySelector('input[name="annotationMode"]:checked').value;

    if (!markers[frame]) markers[frame] = [];

    const dragDist = Math.hypot(coords.x - dragStartX, coords.y - dragStartY);

    if (mode === 'point') {
      // Simple click adds a point
      const pt = { type: 'point', x: Math.round(dragStartX), y: Math.round(dragStartY) };
      attachTagAndColor(pt);
      markers[frame].push(pt);
      undoStack.push({ type: 'add', frame, point: pt });
      redoStack.length = 0;
    } else if (mode === 'box') {
      // Only create box if dragged significantly (more than 5 pixels)
      if (dragDist > 5) {
        const box = { 
          type: 'box', 
          x1: Math.round(dragStartX), 
          y1: Math.round(dragStartY), 
          x2: Math.round(coords.x), 
          y2: Math.round(coords.y) 
        };
        attachTagAndColor(box);
        markers[frame].push(box);
        undoStack.push({ type: 'add', frame, point: box });
        redoStack.length = 0;
      } else {
        // Small drag, treat as point click
        const pt = { type: 'point', x: Math.round(dragStartX), y: Math.round(dragStartY) };
        attachTagAndColor(pt);
        markers[frame].push(pt);
        undoStack.push({ type: 'add', frame, point: pt });
        redoStack.length = 0;
      }
    } else if (mode === 'circle') {
      // Only create circle if dragged significantly
      if (dragDist > 5) {
        const circle = { 
          type: 'circle', 
          cx: Math.round(dragStartX), 
          cy: Math.round(dragStartY), 
          radius: Math.round(dragDist) 
        };
        attachTagAndColor(circle);
        markers[frame].push(circle);
        undoStack.push({ type: 'add', frame, point: circle });
        redoStack.length = 0;
      } else {
        // Small drag, treat as point click
        const pt = { type: 'point', x: Math.round(dragStartX), y: Math.round(dragStartY) };
        attachTagAndColor(pt);
        markers[frame].push(pt);
        undoStack.push({ type: 'add', frame, point: pt });
        redoStack.length = 0;
      }
    } else if (mode === 'square') {
      // Only create square if dragged significantly
      if (dragDist > 5) {
        const square = {
          type: 'square',
          cx: Math.round(dragStartX),
          cy: Math.round(dragStartY),
          radius: Math.round(dragDist)
        };
        attachTagAndColor(square);
        markers[frame].push(square);
        undoStack.push({ type: 'add', frame, point: square });
        redoStack.length = 0;
      } else {
        // Small drag, treat as point click
        const pt = { type: 'point', x: Math.round(dragStartX), y: Math.round(dragStartY) };
        attachTagAndColor(pt);
        markers[frame].push(pt);
        undoStack.push({ type: 'add', frame, point: pt });
        redoStack.length = 0;
      }
    }

    drawFrameOverlay();
  });

  canvas.addEventListener('mouseleave', () => {
    if (isDragging) {
      isDragging = false;
      drawFrameOverlay();
    }
  });

  // Export JSON or CSV
  exportBtn.addEventListener('click', () => {
    const wantCsv = exportFormatCsv.checked;
    const fps = estimateFPS();
    const out = [];
    
    // Build array of {frame, time, markers:[...]}
    for (const k of Object.keys(markers).sort((a,b)=>Number(a)-Number(b))) {
      const markerArr = markers[k];
      if (!markerArr || markerArr.length === 0) continue;
      const frameNum = Number(k);
      const timeSec = +(frameNum / fps).toFixed(4);
      
      // Keep full marker data with type information
      out.push({ frame: frameNum, time: timeSec, markers: markerArr });
    }
    
    // produce a safe filename base from uploaded filename or default
    function safeBaseName(name) {
      if (!name) return 'markers';
      // strip extension and unsafe chars
      const base = name.replace(/\.[^.]+$/, '');
      return base.replace(/[^a-zA-Z0-9-_\.]/g, '_');
    }
    const base = safeBaseName(uploadedFilename);
    // local YYYYMMDD_HHMMSS
    const dt = new Date();
    const pad = (n, z=2) => String(n).padStart(z,'0');
    const tsForName = `${dt.getFullYear()}${pad(dt.getMonth()+1)}${pad(dt.getDate())}_${pad(dt.getHours())}${pad(dt.getMinutes())}${pad(dt.getSeconds())}`;
    const outNameBase = `${base}_${tsForName}`;
    
    if (wantCsv) {
  // CSV columns: frame,time_seconds,marker_index,type,x,y,x1,y1,x2,y2,radius,r,g,b,a,tag,tag_name
  let rows = ['frame,time_seconds,marker_index,type,x,y,x1,y1,x2,y2,radius,r,g,b,a,tag,tag_name'];
      out.forEach(item => {
        item.markers.forEach((m, i) => {
          const idx = i + 1;
          const type = m.type || 'point';
          const cxVal = (m.cx !== undefined) ? m.cx : m.x;
          const cyVal = (m.cy !== undefined) ? m.cy : m.y;
          const rVal = (m.r !== undefined) ? m.r : 0;
          const gVal = (m.g !== undefined) ? m.g : 255;
          const bVal = (m.b !== undefined) ? m.b : 0;
          const aVal = (m.a !== undefined) ? m.a : DEFAULT_ALPHA;
          const tagVal = m.tag || '';
          const cols = [];
          cols.push(item.frame);
          cols.push(item.time);
          cols.push(idx);
          cols.push(type);
          if (type === 'point') {
            // point: x,y
            cols.push(m.x);
            cols.push(m.y);
            // x1,y1,x2,y2,radius empty
            cols.push(''); cols.push(''); cols.push(''); cols.push(''); cols.push('');
          } else if (type === 'box') {
            // box: x1,y1,x2,y2 (place them in x1,y1,x2,y2 columns)
            // leave x,y empty for box
            cols.push(''); cols.push('');
            cols.push(m.x1); cols.push(m.y1); cols.push(m.x2); cols.push(m.y2);
            cols.push(''); // radius
          } else if (type === 'circle') {
            // circle: center in x,y, radius in radius col
            cols.push(cxVal); cols.push(cyVal);
            // x1,y1,x2,y2 empty
            cols.push(''); cols.push(''); cols.push(''); cols.push('');
            cols.push(m.radius || '');
          } else if (type === 'square') {
            // square: center in x,y, radius is half-side
            cols.push(cxVal); cols.push(cyVal);
            // x1,y1,x2,y2 empty
            cols.push(''); cols.push(''); cols.push(''); cols.push('');
            cols.push(m.radius || '');
          } else {
            // unknown type: leave geometry fields empty
            cols.push(''); cols.push(''); cols.push(''); cols.push(''); cols.push(''); cols.push(''); cols.push('');
          }
          // append color and tag fields
          cols.push(rVal); cols.push(gVal); cols.push(bVal); cols.push(aVal); cols.push(tagVal);
          // include tag_name if available (user-editable); leave empty if not edited
          const tagNameVal = (tagVal && tagMap[tagVal] && tagMap[tagVal].tag_name && tagMap[tagVal].tag_name !== String(tagVal)) ? tagMap[tagVal].tag_name : '';
          cols.push(tagNameVal);
          rows.push(cols.join(','));
        });
      });
      const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = outNameBase + '.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
    } else {
      // JSON: include metadata and full marker data
      const exportMeta = {
        filename: uploadedFilename || null,
        exported_at: new Date().toISOString(),
        fps: estimateFPS()
      };
      // Normalize markers so circle uses x,y center (not cx/cy) and box uses x1,y1,x2,y2
      const normalized = out.map(item => ({
        frame: item.frame,
        time: item.time,
        markers: (item.markers || []).map(m => {
          const type = m.type || 'point';
          if (type === 'point') {
            const obj = { type: 'point', x: m.x, y: m.y, r: m.r, g: m.g, b: m.b, a: m.a, tag: m.tag };
            if (m.tag && tagMap[m.tag] && tagMap[m.tag].tag_name && tagMap[m.tag].tag_name !== String(m.tag)) obj.tag_name = tagMap[m.tag].tag_name;
            return obj;
          } else if (type === 'box') {
            const obj = { type: 'box', x1: m.x1, y1: m.y1, x2: m.x2, y2: m.y2, r: m.r, g: m.g, b: m.b, a: m.a, tag: m.tag };
            if (m.tag && tagMap[m.tag] && tagMap[m.tag].tag_name && tagMap[m.tag].tag_name !== String(m.tag)) obj.tag_name = tagMap[m.tag].tag_name;
            return obj;
          } else if (type === 'circle') {
            // use x,y for center in exports
            const cx = (m.cx !== undefined) ? m.cx : m.x;
            const cy = (m.cy !== undefined) ? m.cy : m.y;
            const obj = { type: 'circle', x: cx, y: cy, radius: m.radius, r: m.r, g: m.g, b: m.b, a: m.a, tag: m.tag };
            if (m.tag && tagMap[m.tag] && tagMap[m.tag].tag_name && tagMap[m.tag].tag_name !== String(m.tag)) obj.tag_name = tagMap[m.tag].tag_name;
            return obj;
          } else if (type === 'square') {
            const cx = (m.cx !== undefined) ? m.cx : m.x;
            const cy = (m.cy !== undefined) ? m.cy : m.y;
            const obj = { type: 'square', x: cx, y: cy, radius: m.radius, r: m.r, g: m.g, b: m.b, a: m.a, tag: m.tag };
            if (m.tag && tagMap[m.tag] && tagMap[m.tag].tag_name && tagMap[m.tag].tag_name !== String(m.tag)) obj.tag_name = tagMap[m.tag].tag_name;
            return obj;
          }
          return m;
        })
      }));
      const blob = new Blob([JSON.stringify({ meta: exportMeta, markers: normalized }, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = outNameBase + '.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
  });

  // Undo / Redo logic
  undoBtn.addEventListener('click', () => { performUndo(); });
  redoBtn.addEventListener('click', () => { performRedo(); });

  function performUndo() {
    const op = undoStack.pop(); if (!op) return;
    // helper to compare markers by type/props when reference match fails
    const markersEqual = (a, b) => {
      if (!a || !b) return false;
      if ((a.type || 'point') !== (b.type || 'point')) return false;
      const t = a.type || 'point';
      const tagEq = String(a.tag || '') === String(b.tag || '');
      const colorEq = (Number(a.r||0) === Number(b.r||0)) && (Number(a.g||0) === Number(b.g||0)) && (Number(a.b||0) === Number(b.b||0)) && (Number((a.a!==undefined?a.a:DEFAULT_ALPHA)) === Number((b.a!==undefined?b.a:DEFAULT_ALPHA)));
  if (t === 'point') return Number(a.x) === Number(b.x) && Number(a.y) === Number(b.y) && tagEq && colorEq;
  if (t === 'box') return Number(a.x1) === Number(b.x1) && Number(a.y1) === Number(b.y1) && Number(a.x2) === Number(b.x2) && Number(a.y2) === Number(b.y2) && tagEq && colorEq;
  if (t === 'circle') return Number(a.cx) === Number(b.cx) && Number(a.cy) === Number(b.cy) && Number(a.radius) === Number(b.radius) && tagEq && colorEq;
  if (t === 'square') return Number(a.cx) === Number(b.cx) && Number(a.cy) === Number(b.cy) && Number(a.radius) === Number(b.radius) && tagEq && colorEq;
      return false;
    };

    if (op.type === 'add') {
      const arr = markers[op.frame] || [];
      // prefer reference equality (exact object), fallback to property match
      let idx = arr.indexOf(op.point);
      if (idx === -1) idx = arr.findIndex(p => markersEqual(p, op.point));
      if (idx >= 0) arr.splice(idx,1);
      redoStack.push(op);
    } else if (op.type === 'remove') {
      if (!markers[op.frame]) markers[op.frame] = [];
      // restore at end of array to preserve original ordering roughly
      markers[op.frame].push(op.point);
      redoStack.push(op);
    } else if (op.type === 'clear-frame') {
      markers[op.frame] = op.prevState || [];
      redoStack.push(op);
    } else if (op.type === 'clear-all') {
      // restore prevState which is a shallow copy
      for (const k in markers) delete markers[k];
      Object.assign(markers, op.prevState || {});
      redoStack.push(op);
    }
    drawFrameOverlay();
  }

  function performRedo() {
    const op = redoStack.pop(); if (!op) return;
    const markersEqual = (a, b) => {
      if (!a || !b) return false;
      if ((a.type || 'point') !== (b.type || 'point')) return false;
      const t = a.type || 'point';
      const tagEq = String(a.tag || '') === String(b.tag || '');
      const colorEq = (Number(a.r||0) === Number(b.r||0)) && (Number(a.g||0) === Number(b.g||0)) && (Number(a.b||0) === Number(b.b||0)) && (Number((a.a!==undefined?a.a:DEFAULT_ALPHA)) === Number((b.a!==undefined?b.a:DEFAULT_ALPHA)));
  if (t === 'point') return Number(a.x) === Number(b.x) && Number(a.y) === Number(b.y) && tagEq && colorEq;
  if (t === 'box') return Number(a.x1) === Number(b.x1) && Number(a.y1) === Number(b.y1) && Number(a.x2) === Number(b.x2) && Number(a.y2) === Number(b.y2) && tagEq && colorEq;
  if (t === 'circle') return Number(a.cx) === Number(b.cx) && Number(a.cy) === Number(b.cy) && Number(a.radius) === Number(b.radius) && tagEq && colorEq;
  if (t === 'square') return Number(a.cx) === Number(b.cx) && Number(a.cy) === Number(b.cy) && Number(a.radius) === Number(b.radius) && tagEq && colorEq;
      return false;
    };

    if (op.type === 'add') {
      if (!markers[op.frame]) markers[op.frame] = [];
      markers[op.frame].push(op.point);
      undoStack.push(op);
    } else if (op.type === 'remove') {
      const arr = markers[op.frame] || [];
      let idx = arr.indexOf(op.point);
      if (idx === -1) idx = arr.findIndex(p => markersEqual(p, op.point));
      if (idx >= 0) arr.splice(idx,1);
      undoStack.push(op);
    } else if (op.type === 'clear-frame') {
      const prev = markers[op.frame];
      op.prevState = prev;
      delete markers[op.frame];
      undoStack.push(op);
    } else if (op.type === 'clear-all') {
      const prev = {};
      for (const k in markers) prev[k] = markers[k];
      for (const k in markers) delete markers[k];
      undoStack.push(op);
    }
    drawFrameOverlay();
  }

  // Keyboard shortcuts
  // Left/Right: prev/next frame, Space: play/pause, Backspace: delete nearest, Escape: clear markers for current frame
  document.addEventListener('keydown', (e) => {
    const tag = document.activeElement && document.activeElement.tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA') return; // don't hijack typing

    // track alnum keys for tagging while clicking
    if (/^[A-Za-z0-9]$/.test(e.key)) {
      lastKeyPressed = e.key;
      return;
    }

    if (e.key === 'ArrowLeft') { e.preventDefault(); prevBtn.click(); }
    else if (e.key === 'ArrowRight') { e.preventDefault(); nextBtn.click(); }
    else if (e.key === ' ') { e.preventDefault(); playPauseBtn.click(); }
    else if (e.key === 'Backspace') { e.preventDefault(); // delete nearest marker to mouse (or center)
      const rect = canvas.getBoundingClientRect();
      const mx = (lastMousePos.x !== undefined) ? lastMousePos.x : rect.left + rect.width/2;
      const my = (lastMousePos.y !== undefined) ? lastMousePos.y : rect.top + rect.height/2;
      const cssX = mx - rect.left; const cssY = my - rect.top;
      const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
      const x = cssX * scaleX; const y = cssY * scaleY;
      const frame = getCurrentFrameIndex();
      const arr = markers[frame] || [];
      if (arr.length === 0) return;
      let bestIdx = -1; let bestDist = Infinity;
      for (let i=0; i<arr.length; i++){
        const m = arr[i];
        let d = Infinity;
        if (!m.type || m.type === 'point') {
          d = Math.hypot(m.x - x, m.y - y);
        } else if (m.type === 'box') {
          const cx = (m.x1 + m.x2) / 2;
          const cy = (m.y1 + m.y2) / 2;
          d = Math.hypot(cx - x, cy - y);
        } else if (m.type === 'circle' || m.type === 'square') {
          const cx = (m.cx !== undefined) ? m.cx : m.x;
          const cy = (m.cy !== undefined) ? m.cy : m.y;
          d = Math.hypot(cx - x, cy - y);
        }
        if (d < bestDist) { bestDist = d; bestIdx = i; }
      }
      if (bestDist < 40) {
        const removed = arr.splice(bestIdx, 1)[0];
        markers[frame] = arr;
        undoStack.push({ type: 'remove', frame, point: removed });
        redoStack.length = 0;
        drawFrameOverlay();
      }
    }
    else if (e.key === 'Escape') { e.preventDefault(); // clear current frame markers
      const f = getCurrentFrameIndex();
      if (markers[f]) {
        const prev = markers[f].slice();
        undoStack.push({ type:'clear-frame', frame:f, prevState: prev });
        redoStack.length = 0;
        delete markers[f];
        drawFrameOverlay();
      }
    }
  });

  // clear lastKeyPressed on keyup
  document.addEventListener('keyup', (e) => {
    if (/^[A-Za-z0-9]$/.test(e.key)) lastKeyPressed = null;
  });

  // track last mouse pos over canvas for keyboard delete
  let lastMousePos = {};
  canvas.addEventListener('mousemove', (ev) => { lastMousePos.x = ev.clientX; lastMousePos.y = ev.clientY; });

  clearBtn.addEventListener('click', () => {
    const prev = {};
    for (const k in markers) prev[k] = markers[k];
    undoStack.push({ type: 'clear-all', prevState: prev });
    for (const k in markers) delete markers[k];
    drawFrameOverlay();
  });

  // goto frame
  gotoFrameBtn.addEventListener('click', () => {
    const v = parseInt(gotoFrameInput.value);
    if (!isFinite(v) || v < 0) return;
    seekToFrame(v);
  });
  firstFrameBtn.addEventListener('click', () => { seekToFrame(0); });

  // Show FPS warning on hover (tooltip handled by title); make icon visible if fps is estimated
  fpsWarn.addEventListener('dblclick', () => { fpsInput.removeAttribute('readonly'); fpsInput.focus(); });
  fpsInput.addEventListener('input', () => { fpsWarn.style.visibility = 'hidden'; });

  // small UI update loop to keep labels updated when video playing or seeking
  setInterval(() => {
    if (video.readyState >= 2) {
      updateFrameLabels();
    }
  }, 250);

  // Tag mapping UI
  const toggleTagMapBtn = document.getElementById('toggleTagMap');
  const tagMapList = document.getElementById('tagMapList');
  function updateTagMappingUI() {
    const keys = Object.keys(tagMap);
    if (!keys.length) {
      document.getElementById('tagMappingContainer').style.display = 'none';
      return;
    }
    document.getElementById('tagMappingContainer').style.display = 'block';
    tagMapList.innerHTML = '';
    keys.forEach(tag => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.gap = '8px';
      const c = tagMap[tag].color;
      const keySpan = document.createElement('div'); keySpan.textContent = tag; keySpan.style.width = '24px';
      const nameInput = document.createElement('input');
      nameInput.value = tagMap[tag].tag_name || tag;
      nameInput.style.flex = '1';
      nameInput.addEventListener('input', () => { tagMap[tag].tag_name = nameInput.value; drawFrameOverlay(); renderPointsList(getCurrentFrameIndex(), markers[getCurrentFrameIndex()] || []); });
      // color input (hex) and alpha input — use color input as the swatch
      const colorInput = document.createElement('input');
      colorInput.type = 'color';
      colorInput.value = rgbToHex(c.r,c.g,c.b);
      colorInput.title = 'Edit tag color';
      colorInput.style.width = '24px'; colorInput.style.height = '24px'; colorInput.style.padding = '0'; colorInput.style.border = '1px solid #ccc'; colorInput.style.marginRight = '6px';
      colorInput.style.verticalAlign = 'middle';
      // reflect alpha by adjusting opacity of the control (color input can't carry alpha)
      colorInput.style.opacity = String(typeof c.a === 'number' ? c.a : DEFAULT_ALPHA);
      colorInput.addEventListener('input', () => {
        const rgb = hexToRgb(colorInput.value);
        if (!rgb) return;
        tagMap[tag].color.r = rgb.r; tagMap[tag].color.g = rgb.g; tagMap[tag].color.b = rgb.b;
        // update markers with this tag to new color
        for (const f in markers) {
          (markers[f] || []).forEach(m => { if (m.tag === tag) { m.r = rgb.r; m.g = rgb.g; m.b = rgb.b; } });
        }
        drawFrameOverlay(); renderPointsList(getCurrentFrameIndex(), markers[getCurrentFrameIndex()] || []);
      });

      const alphaInput = document.createElement('input');
      alphaInput.type = 'number'; alphaInput.step = '0.01'; alphaInput.min = '0'; alphaInput.max = '1'; alphaInput.value = String(typeof c.a === 'number' ? c.a : DEFAULT_ALPHA);
      alphaInput.style.width = '64px'; alphaInput.title = 'Alpha (0-1)';
      alphaInput.addEventListener('input', () => {
        const v = parseFloat(alphaInput.value);
        if (!isFinite(v)) return;
        tagMap[tag].color.a = v;
        for (const f in markers) {
          (markers[f] || []).forEach(m => { if (m.tag === tag) { m.a = v; } });
        }
        drawFrameOverlay(); renderPointsList(getCurrentFrameIndex(), markers[getCurrentFrameIndex()] || []);
        // reflect alpha in color input opacity
        colorInput.style.opacity = String(v);
      });

      row.appendChild(colorInput); row.appendChild(keySpan); row.appendChild(nameInput); row.appendChild(alphaInput);
      tagMapList.appendChild(row);
    });
  }
  toggleTagMapBtn.addEventListener('click', () => {
    if (tagMapList.style.display === 'none' || tagMapList.style.display === '') {
      tagMapList.style.display = 'block';
      toggleTagMapBtn.textContent = 'Tags ▲';
    } else {
      tagMapList.style.display = 'none';
      toggleTagMapBtn.textContent = 'Tags ▼';
    }
  });

  // Initial placeholder canvas size
  canvas.width = 640; canvas.height = 360;
  ctx.fillStyle = '#222'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#999'; ctx.font = '14px sans-serif'; ctx.fillText('Load a video to start, drag and drop a video file here', 10, 30);
  </script>

  <!-- Teach Me collapsible tutorial -->
  <div style="margin-top:18px; border-top:1px solid #eee; padding-top:12px;">
    <button id="teachBtn" style="padding:8px 12px; background:#c00; color:#fff; border:1px solid #900; border-radius:4px;">Teach Me!</button>
    <div id="teachSection" style="display:none; margin-top:12px; background:#fafafa; border:1px solid #eee; padding:12px;">
      <h3>Quick start</h3>
      <ol>
        <li>Click "Choose file" or drag & drop a video onto the page.</li>
        <li>Optionally import existing annotations (JSON/CSV) using the Import control or by dropping the file anywhere. You'll be asked to Replace or Merge.</li>
        <li><span style="color:red">Manually set the FPS (frames per seconds) of the video. Currently the FPS auto-detection is typically wrong.</span></li>
        <li>Scrub the video with the timeline slider (pauses while dragging, resumes on release) or use the mouse wheel over the canvas to step frames by the configured step size.</li>
        <li>Choose your annotation mode: <strong>Point</strong>, <strong>Bounding Box</strong>, <strong>Circle</strong>, or <strong>Square</strong>.</li>
        <li>Use Prev / Next or Arrow keys to step frames (adjust "frames per step" if you need larger jumps).</li>
        <li>Click or click-and-drag on the canvas to add markers. Shift+Click removes the nearest marker on that frame.</li>
        <li><strong>Tagging:</strong> Hold any alphanumeric key (case-sensitive) while clicking to assign a tag to a marker. Tags are case-sensitive.</li>
        <li><strong>Tag mapping:</strong> Click "Tags" to open the tag mapping UI. For each tag, you can edit the color (leftmost color picker), alpha, and tag name. The color picker acts as the swatch and reflects alpha via opacity. Changes update all markers with that tag. Tag names and colors are exported/imported in both JSON and CSV.</li>
        <li>Use Undo / Redo to revert changes. Click Export (choose JSON or CSV).</li>
      </ol>

      <h3>Detailed instructions</h3>
  <p><strong>Uploading:</strong> Use the file picker or drag & drop your video file. The tool will try to estimate the video's FPS; if it shows a warning (⚠), double-click it to edit the FPS manually for exact frame mapping.</p>
    <p><strong>Importing annotations:</strong> You can import annotations from JSON or CSV either via the Import control (next to Export) or by dropping the file anywhere on the page. You'll be prompted to <em>Replace</em> existing annotations or <em>Merge</em> into them. Supported formats:
  <br>• JSON (this tool's export): { meta, markers: [ { frame, time, markers: [ {type:'point'|'box'|'circle'|'square', ...coords, r,g,b,a,tag,tag_name?} ] } ] }
  <br>• Legacy JSON: [ { frame, time, points: [ {x,y} ] } ] or { [frame]: [ {x,y} ] }
  <br>• CSV (this tool's export): frame,time_seconds,marker_index,type,x,y,x1,y1,x2,y2,radius,r,g,b,a,tag,tag_name
  <br>• Legacy CSV: frame,time_seconds,point_index,x,y (points only)</p>
      <p><strong>Navigating frames:</strong> Click "Prev" / "Next" or use the Left/Right arrow keys. The "frames per step" input controls how many frames are skipped when stepping. You can also jump to a specific frame number using the "Go to frame" input and button, or return to the first frame with "First Frame".</p>
      <p><strong>Annotation Modes:</strong></p>
      <ul>
        <li><strong>Point:</strong> Click to place a single point marker at that location.</li>
        <li><strong>Bounding Box:</strong> Click and drag to draw a rectangular box. If you only click (drag less than 5 pixels), a point will be added instead.</li>
        <li><strong>Circle:</strong> Click and drag to draw a circle. The click location becomes the center, and the drag distance becomes the radius. Small drags (less than 5 pixels) create a point instead.</li>
        <li><strong>Square:</strong> Click and drag to draw a square centered at the click location. The drag distance defines the half-side (stored as <code>radius</code>), so the full side length is 2×radius. Small drags (less than 5 pixels) create a point instead.</li>
      </ul>
      <p><strong>Tagging and Tag Mapping:</strong></p>
      <ul>
        <li><strong>Assign tags:</strong> Hold any alphanumeric key (case-sensitive) while clicking to assign a tag to a marker. Tags are case-sensitive and can be any single letter or digit.</li>
        <li><strong>Tag mapping UI:</strong> Click "Tags" to open the tag mapping panel. Each tag row shows: color picker (leftmost), tag key, editable tag name, and alpha input (0–1). The color picker acts as the swatch and reflects alpha via opacity.</li>
        <li><strong>Edit tag color/alpha:</strong> Changing these updates all markers with that tag. Editing the tag name updates the human-readable name for that tag (exported as tag_name).</li>
        <li><strong>Export/import:</strong> Tag color and tag_name are preserved in both JSON and CSV import/export. Tag keys are case-sensitive.</li>
      </ul>
  <p><strong>Removing markers:</strong> Shift+Click near a marker to remove it. Press <kbd>Backspace</kbd> to delete the nearest marker to the mouse cursor (or center if cursor is not over the canvas). Press <kbd>Esc</kbd> to clear all markers on the current frame.</p>
      <p><strong>Undo / Redo:</strong> Use the Undo and Redo buttons to step through recent add/remove/clear actions. Clearing the current frame or all markers is also undoable.</p>
  <p><strong>Exporting:</strong> Choose JSON or CSV format. JSON exports include metadata (filename, export timestamp, fps) plus markers grouped by frame with time in seconds and full marker data (type, coordinates, color, tag, tag_name). CSV exports one row per marker with columns: frame, time_seconds, marker_index, type, x, y, x1, y1, x2, y2, radius, r, g, b, a, tag, tag_name (with empty fields for inapplicable coordinates). Filenames are based on the original filename plus a local timestamp.</p>

      <h3>Features (at a glance)</h3>
      <ul>
        <li>Video upload via file picker or drag & drop</li>
        <li>Import annotations from JSON/CSV (replace or merge)</li>
        <li>Elegant scrubbing with a timeline slider and mouse wheel stepping</li>
        <li>Annotation modes: Point, Bounding Box, Circle, and Square</li>
        <li>Per-frame marking with pixel coordinates</li>
        <li>Visual preview while dragging boxes, circles, and squares</li>
        <li>Estimated FPS detection; editable FPS override</li>
        <li>Frame navigation (Prev/Next, keyboard arrows, jump to frame, first frame)</li>
        <li>Undo / Redo for all marker operations</li>
        <li>Export JSON (with metadata and full marker data) or CSV (with type column and all coordinate fields)</li>
  <li>Keyboard shortcuts: ← → (frame), Space (play/pause), Esc (clear frame), Backspace (delete nearest)</li>
      </ul>
      <p class="hint">Click "Teach Me!" again to hide this tutorial.</p>
    </div>
  </div>

  <script>
    // Teach Me toggle
    const teachBtn = document.getElementById('teachBtn');
    const teachSection = document.getElementById('teachSection');
    teachBtn.addEventListener('click', () => {
      if (teachSection.style.display === 'none') {
        teachSection.style.display = 'block';
        teachBtn.textContent = 'Hide Tutorial';
      } else {
        teachSection.style.display = 'none';
        teachBtn.textContent = 'Teach Me!';
      }
    });
  </script>
</body>
</html>
