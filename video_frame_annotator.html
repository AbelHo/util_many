<!--
Programmer Reference Summary
---------------------------
Video Frame Annotator: A browser-based tool for annotating video frames with points, bounding boxes, and circles.

Key Features:
- Upload video via file input or drag & drop (no server, all client-side)
- Frame navigation: step, jump, play/pause, go to frame
- Annotation modes: Point (click), Bounding Box (click-drag), Circle (click-drag)
- Markers are stored per-frame, with undo/redo support for all actions
- Remove markers with shift+click or keyboard shortcut (D)
- Export annotations as JSON (with metadata and all marker types) or CSV (one row per marker, type and coordinates)
- Import annotations from JSON or CSV files, with option to merge or replace existing
- FPS is estimated but user-editable; accurate FPS is critical for correct frame mapping
- Minimal CSS, no dependencies, no build step

Usage Instructions:
- Open the HTML file in a browser
- Load a video, set FPS if needed
- Select annotation mode, annotate frames as needed
- Use Undo/Redo, clear, and export as required

Maintenance Notes:
- All logic is in this file (no external JS)
- Markers data structure: { [frameNumber]: [ {type, ...coords} ] }
- Undo/redo stacks store operation objects for all marker types
- UI and instructions are updated to reflect all annotation modes
- See README.md for project-wide conventions
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="Video Frame Annotator - A browser-based tool for annotating video frames with points, bounding boxes, and circles. Navigate frame-by-frame, draw annotations with drag-and-drop, and export to JSON or CSV. Perfect for video analysis, object tracking, and dataset creation. No installation required." />
  <meta name="keywords" content="video annotation, frame annotator, bounding box, video labeling, object detection, computer vision, video analysis, dataset creation, frame-by-frame annotation, point annotation, circle annotation" />
  <title>Video Frame Annotator</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; margin: 20px; }
    #player { display:flex; gap:20px; align-items:flex-start; }
    video, canvas { background: #111; max-width: 80vw; border: 1px solid #ccc; }
    .controls { display:flex; gap:8px; flex-direction:column; }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    button { padding:6px 10px; }
    #pointsList { max-height:200px; overflow:auto; border:1px solid #eee; padding:8px; }
    .point-item { font-size:13px; }
    .hint { color:#666; font-size:13px; }
  </style>
</head>
<body>
  <h2>Video Frame Annotator</h2>
  <p class="hint">Upload a video, navigate frames, and annotate with points, bounding boxes, or circles. Click/drag to add markers (shift+click to remove nearest). Export as JSON or CSV.</p>

  <div class="row">
    <input id="fileInput" type="file" accept="video/*" />
    <label><input id="frameStepInput" type="number" value="1" min="1" style="width:80px"> frames per step</label>
    <label title="Estimated FPS (editable)" style="color:red;"><strong>FPS:</strong> <input id="fpsInput" type="number" step="0.01" style="width:80px"> <span id="fpsWarn" style="margin-left:6px; visibility:hidden;" title="FPS is estimated — double-click to edit">⚠</span></label>
  </div>
  <div class="row">
    <strong>Annotation Mode:</strong>
    <label><input id="modePoint" type="radio" name="annotationMode" value="point" checked> Point</label>
    <label><input id="modeBox" type="radio" name="annotationMode" value="box"> Bounding Box</label>
    <label><input id="modeCircle" type="radio" name="annotationMode" value="circle"> Circle</label>
  </div>
  <div class="row">
    <strong>Export Format:</strong>
    <label><input id="exportFormat" type="radio" name="format" value="json"> JSON</label>
    <label><input id="exportFormatCsv" type="radio" name="format" value="csv" checked> CSV</label>
    <button id="exportBtn">Export</button>
    <button id="undoBtn">Undo</button>
    <button id="redoBtn">Redo</button>
    <button id="clearBtn">Clear All Markers</button>
  </div>
  <div class="row">
    <label>Import annotations: <input id="importInput" type="file" accept=".json,.csv" /></label>
    <button id="importBtn">Import</button>
    <span class="hint">(You can also drop a JSON/CSV file anywhere to import)</span>
  </div>
  <div class="row">
    <label>Go to frame: <input id="gotoFrameInput" type="number" min="0" style="width:120px"></label>
    <button id="gotoFrameBtn">Go</button>
    <button id="firstFrameBtn">First Frame</button>
  </div>
  <div class="row">
    <input id="scrubSlider" type="range" min="0" value="0" step="1" style="flex:1; max-width:520px" disabled>
    <label>Time: <span id="currentTime">0:00.000</span> / <span id="totalTime">0:00.000</span></label>
  </div>

  <div id="player">
    <div>
  <video id="video" crossorigin="anonymous" playsinline style="display:none; width:0; height:0;"></video>
  <canvas id="canvas"></canvas>
      <div class="row">
        <button id="prevBtn">◀ Prev</button>
        <button id="nextBtn">Next ▶</button>
        <button id="playPauseBtn">Play</button>
        <label>Frame: <span id="frameIndex">0</span>/<span id="frameCount">0</span></label>
      </div>
      <div class="row">
        <label>Current frame markers: <span id="markerCount">0</span></label>
        <span class="hint">(use slider or mouse wheel to scrub; click/drag to add, shift+click to remove nearest)</span>
      </div>
    </div>

    <div class="controls">
      <div><strong>Markers per frame</strong></div>
      <div id="pointsList">No frame loaded.</div>
    </div>
  </div>

  <script>
  // Minimal, standalone video frame annotator tool.
  const fileInput = document.getElementById('fileInput');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const playPauseBtn = document.getElementById('playPauseBtn');
  const frameIndexLabel = document.getElementById('frameIndex');
  const frameCountLabel = document.getElementById('frameCount');
  const markerCountLabel = document.getElementById('markerCount');
  const pointsList = document.getElementById('pointsList');
  const exportBtn = document.getElementById('exportBtn');
  const clearBtn = document.getElementById('clearBtn');
  const frameStepInput = document.getElementById('frameStepInput');
  const exportFormat = document.getElementById('exportFormat');
  const exportFormatCsv = document.getElementById('exportFormatCsv');
  const fpsInput = document.getElementById('fpsInput');
  const fpsWarn = document.getElementById('fpsWarn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const gotoFrameInput = document.getElementById('gotoFrameInput');
  const gotoFrameBtn = document.getElementById('gotoFrameBtn');
  const firstFrameBtn = document.getElementById('firstFrameBtn');
  const modePoint = document.getElementById('modePoint');
  const modeBox = document.getElementById('modeBox');
  const modeCircle = document.getElementById('modeCircle');
  const importInput = document.getElementById('importInput');
  const importBtn = document.getElementById('importBtn');
  const scrubSlider = document.getElementById('scrubSlider');
  const currentTimeLabel = document.getElementById('currentTime');
  const totalTimeLabel = document.getElementById('totalTime');

  // Data structure: map frameNumber -> array of markers
  // Each marker: {type:'point', x, y} OR {type:'box', x1, y1, x2, y2} OR {type:'circle', cx, cy, radius}
  const markers = {};
  let detectedFPS = null; // will hold detected fps when available
  let uploadedFilename = null;

  // Undo/redo stacks: store simple operations {type:'add'|'remove'|'clear-frame'|'clear-all', frame, point, prevState}
  const undoStack = [];
  const redoStack = [];

  let rafId = null;
  let playing = false;
  let isScrubbing = false;
  let wasPlayingOnScrub = false;

  // Drawing state for drag operations
  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragCurrentX = 0;
  let dragCurrentY = 0;

  function resetCanvasSize() {
    const w = video.videoWidth;
    const h = video.videoHeight;
    if (!w || !h) return;
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = Math.min(w, window.innerWidth*0.75) + 'px';
    canvas.style.height = (canvas.height * (parseInt(canvas.style.width)/canvas.width)) + 'px';
  }

  function drawFrameOverlay() {
    if (!video.videoWidth) return;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // draw current video frame into canvas
    try {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    } catch(e) {
      // drawImage may fail if video not ready
    }

    // draw markers for current frame
    const frame = getCurrentFrameIndex();
    const arr = markers[frame] || [];
    for (let i = 0; i < arr.length; i++) {
      const m = arr[i];
      drawMarker(m, i+1);
    }

    // draw drag preview if dragging
    if (isDragging) {
      drawDragPreview();
    }

    markerCountLabel.textContent = arr.length;
    renderPointsList(frame, arr);
  }

  function drawMarker(marker, index) {
    ctx.save();
    ctx.strokeStyle = 'lime';
    ctx.fillStyle = 'rgba(0,255,0,0.7)';
    ctx.lineWidth = 2;

    if (!marker.type || marker.type === 'point') {
      // Draw point marker
      ctx.beginPath();
      ctx.arc(marker.x, marker.y, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = 'black';
      ctx.font = '12px sans-serif';
      ctx.fillText(String(index), marker.x+8, marker.y+4);
    } else if (marker.type === 'box') {
      // Draw bounding box
      const x = Math.min(marker.x1, marker.x2);
      const y = Math.min(marker.y1, marker.y2);
      const w = Math.abs(marker.x2 - marker.x1);
      const h = Math.abs(marker.y2 - marker.y1);
      ctx.fillStyle = 'rgba(0,255,0,0.2)';
      ctx.fillRect(x, y, w, h);
      ctx.strokeRect(x, y, w, h);
      ctx.fillStyle = 'lime';
      ctx.font = '12px sans-serif';
      ctx.fillText(String(index), x+4, y+14);
    } else if (marker.type === 'circle') {
      // Draw circle
      ctx.beginPath();
      ctx.arc(marker.cx, marker.cy, marker.radius, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(0,255,0,0.2)';
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = 'lime';
      ctx.font = '12px sans-serif';
      ctx.fillText(String(index), marker.cx+marker.radius+4, marker.cy);
    }

    ctx.restore();
  }

  function drawDragPreview() {
    ctx.save();
    ctx.strokeStyle = 'yellow';
    ctx.fillStyle = 'rgba(255,255,0,0.2)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);

    const mode = document.querySelector('input[name="annotationMode"]:checked').value;
    if (mode === 'box') {
      const x = Math.min(dragStartX, dragCurrentX);
      const y = Math.min(dragStartY, dragCurrentY);
      const w = Math.abs(dragCurrentX - dragStartX);
      const h = Math.abs(dragCurrentY - dragStartY);
      ctx.fillRect(x, y, w, h);
      ctx.strokeRect(x, y, w, h);
    } else if (mode === 'circle') {
      const radius = Math.hypot(dragCurrentX - dragStartX, dragCurrentY - dragStartY);
      ctx.beginPath();
      ctx.arc(dragStartX, dragStartY, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    }

    ctx.restore();
  }

  function renderPointsList(frame, arr) {
    pointsList.innerHTML = '';
    const title = document.createElement('div');
    title.textContent = 'Frame ' + frame + ' — ' + arr.length + ' marker(s)';
    title.style.fontWeight = '600';
    title.style.marginBottom = '6px';
    pointsList.appendChild(title);
    if (arr.length === 0) {
      const note = document.createElement('div');
      note.textContent = 'No markers for this frame.';
      pointsList.appendChild(note);
      return;
    }
    arr.forEach((m, i) => {
      const d = document.createElement('div');
      d.className = 'point-item';
      if (!m.type || m.type === 'point') {
        d.textContent = `${i+1}: Point (${Math.round(m.x)}, ${Math.round(m.y)})`;
      } else if (m.type === 'box') {
        d.textContent = `${i+1}: Box (${Math.round(m.x1)}, ${Math.round(m.y1)}) to (${Math.round(m.x2)}, ${Math.round(m.y2)})`;
      } else if (m.type === 'circle') {
        d.textContent = `${i+1}: Circle center (${Math.round(m.cx)}, ${Math.round(m.cy)}) radius ${Math.round(m.radius)}`;
      }
      pointsList.appendChild(d);
    });
  }

  // Convert video currentTime to frame index (integer)
  function getCurrentFrameIndex() {
    const fps = estimateFPS();
    const frame = Math.round(video.currentTime * fps);
    return frame;
  }

  // Heuristic to estimate fps from media (some videos don't expose fps); fallback to 25
  function estimateFPS() {
    // Prefer user-entered FPS, then detectedFPS, otherwise fallback to 25
    const user = parseFloat(fpsInput.value);
    if (isFinite(user) && user > 0) return user;
    if (detectedFPS && isFinite(detectedFPS) && detectedFPS > 0) return detectedFPS;
    const defaultFPS = 25;
    // Try to infer from video.getVideoPlaybackQuality() if available (best-effort)
    try {
      if (video.getVideoPlaybackQuality) {
        const q = video.getVideoPlaybackQuality();
        if (q && q.totalVideoFrames && video.duration) {
          const guessed = q.totalVideoFrames / video.duration;
          if (isFinite(guessed) && guessed > 1 && guessed < 1000) return Math.round(guessed);
        }
      }
    } catch(e) {}
    return defaultFPS;
  }

  // Seek to a specific frame index
  function seekToFrame(frameIndex) {
    const fps = estimateFPS();
    video.currentTime = frameIndex / fps;
  }

  function updateFrameLabels() {
    const fps = estimateFPS();
    const totalFrames = Math.max(0, Math.round(video.duration * fps));
    frameCountLabel.textContent = totalFrames;
    frameIndexLabel.textContent = getCurrentFrameIndex();
    // Update scrub slider and time labels
    if (Number.isFinite(video.duration)) {
      totalTimeLabel.textContent = formatTime(video.duration);
    } else {
      totalTimeLabel.textContent = '0:00.000';
    }
    currentTimeLabel.textContent = formatTime(video.currentTime || 0);
    const maxFrame = Math.max(0, totalFrames - 1);
    if (scrubSlider) {
      scrubSlider.max = String(maxFrame);
      scrubSlider.step = '1';
      scrubSlider.disabled = !(video.readyState >= 1);
      if (!isScrubbing) {
        const cf = getCurrentFrameIndex();
        scrubSlider.value = String(Math.min(Math.max(0, cf), maxFrame));
      }
    }
  }

  function formatTime(sec) {
    if (!Number.isFinite(sec) || sec < 0) sec = 0;
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    const ms = Math.floor((sec - Math.floor(sec)) * 1000);
    return `${m}:${String(s).padStart(2,'0')}.${String(ms).padStart(3,'0')}`;
  }

  // Navigation
  prevBtn.addEventListener('click', () => {
    const step = parseInt(frameStepInput.value) || 1;
    const idx = getCurrentFrameIndex() - step;
    seekToFrame(Math.max(0, idx));
  });
  nextBtn.addEventListener('click', () => {
    const step = parseInt(frameStepInput.value) || 1;
    const idx = getCurrentFrameIndex() + step;
    seekToFrame(Math.max(0, idx));
  });

  playPauseBtn.addEventListener('click', () => {
    if (playing) { video.pause(); } else { video.play(); }
  });

  video.addEventListener('play', () => { playing = true; playPauseBtn.textContent = 'Pause'; tick(); });
  video.addEventListener('pause', () => { playing = false; playPauseBtn.textContent = 'Play'; cancelAnimationFrame(rafId); });

  function tick() {
    drawFrameOverlay();
    updateFrameLabels();
    rafId = requestAnimationFrame(tick);
  }

  // When seeking completes, redraw overlay
  video.addEventListener('seeked', () => {
    drawFrameOverlay();
    updateFrameLabels();
  });

  // Scrubbing interactions
  if (scrubSlider) {
    scrubSlider.addEventListener('pointerdown', () => {
      wasPlayingOnScrub = playing;
      if (playing) video.pause();
      isScrubbing = true;
    });
    scrubSlider.addEventListener('input', () => {
      const f = parseInt(scrubSlider.value) || 0;
      seekToFrame(f);
      drawFrameOverlay();
      updateFrameLabels();
    });
    const endScrub = () => {
      if (!isScrubbing) return;
      isScrubbing = false;
      if (wasPlayingOnScrub) video.play();
    };
    scrubSlider.addEventListener('pointerup', endScrub);
    scrubSlider.addEventListener('pointercancel', endScrub);
    scrubSlider.addEventListener('change', () => {
      // Ensure final position applied
      const f = parseInt(scrubSlider.value) || 0;
      seekToFrame(f);
      drawFrameOverlay();
      updateFrameLabels();
      endScrub();
    });
  }

  // File input
  fileInput.addEventListener('change', (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    uploadedFilename = file.name;
    const url = URL.createObjectURL(file);
    video.src = url;
    video.load();
    video.addEventListener('loadedmetadata', () => {
      resetCanvasSize();
      // Attempt to read FPS from file metadata if available via mediaTracks (some browsers expose frameRate)
      detectedFPS = null;
      try {
        const tracks = video.webkitVideoDecodedByteCount !== undefined ? video.webkitDecodedFrameCount : null;
      } catch(e) {}
      // Some browsers expose frameRate on the first video track via mediaStreamTrack.getSettings (rare on local files)
      // We'll also try to probe playback quality after a short play to populate totalVideoFrames
      drawFrameOverlay();
      updateFrameLabels();
      // quick probe: play briefly muted to let getVideoPlaybackQuality gather frames
      const probe = async () => {
        try {
          video.muted = true;
          await video.play();
          await new Promise(r => setTimeout(r, 200));
          video.pause();
          video.muted = false;
          // try to compute fps from playbackQuality
          if (video.getVideoPlaybackQuality) {
            const q = video.getVideoPlaybackQuality();
            if (q && q.totalVideoFrames && video.duration) {
              const guessed = q.totalVideoFrames / video.duration;
              if (isFinite(guessed) && guessed > 1 && guessed < 1000) detectedFPS = Math.round(guessed);
            }
          }
        } catch(e) {
          // ignore probe errors
        }
        updateFrameLabels();
        drawFrameOverlay();
        // reflect detectedFPS in UI
        if (detectedFPS) { fpsInput.value = detectedFPS; fpsWarn.style.visibility = 'visible'; }
      };
      probe();
    }, { once: true });
  });

  // Drag & drop support for the whole document
  ['dragenter','dragover'].forEach(evt => document.addEventListener(evt, (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; }));
  document.addEventListener('drop', (e) => {
    e.preventDefault();
    const files = Array.from(e.dataTransfer.files || []);
    if (!files.length) return;

    // Handle video files (first one)
    const videoFile = files.find(file => file.type.startsWith('video/') || /\.(mp4|mov|avi|webm|mkv)$/i.test(file.name));
    if (videoFile) {
      fileInput.files = e.dataTransfer.files; // keep default behavior
      uploadedFilename = videoFile.name;
      const url = URL.createObjectURL(videoFile);
      video.src = url;
      video.load();
      video.addEventListener('loadedmetadata', () => { resetCanvasSize(); drawFrameOverlay(); updateFrameLabels(); }, { once: true });
    }

    // Handle annotation files (all .json/.csv)
    const annoFiles = files.filter(file => /\.(json|csv)$/i.test(file.name) || /json|csv/.test(file.type));
    if (annoFiles.length) {
      const replace = confirm('Import annotations from dropped file(s). Replace existing annotations?\nOK = Replace, Cancel = Merge');
      annoFiles.forEach(f => importAnnotationsFile(f, replace));
    }
  });

  // Import controls
  importBtn.addEventListener('click', () => {
    if (importInput.files && importInput.files[0]) {
      const file = importInput.files[0];
      const replace = confirm('Replace existing annotations?\nOK = Replace, Cancel = Merge');
      importAnnotationsFile(file, replace);
    } else {
      alert('Please choose a JSON or CSV file to import.');
    }
  });

  function importAnnotationsFile(file, replace) {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const name = file.name.toLowerCase();
        if (name.endsWith('.json')) {
          const text = reader.result;
          loadAnnotationsFromJsonText(String(text), replace);
        } else if (name.endsWith('.csv')) {
          const text = reader.result;
          loadAnnotationsFromCsvText(String(text), replace);
        } else if (/json/.test(file.type)) {
          const text = reader.result;
          loadAnnotationsFromJsonText(String(text), replace);
        } else if (/csv/.test(file.type) || name.includes('.csv')) {
          const text = reader.result;
          loadAnnotationsFromCsvText(String(text), replace);
        } else {
          alert('Unsupported annotation file: ' + file.name);
        }
      } catch(err) {
        console.error('Import failed', err);
        alert('Failed to import annotations: ' + err.message);
      }
    };
    reader.onerror = () => alert('Failed to read file: ' + file.name);
    reader.readAsText(file);
  }

  function loadAnnotationsFromJsonText(text, replace) {
    const data = JSON.parse(text);
    // Accept multiple shapes
    // 1) { meta, markers: [ { frame, time, markers: [ {type,...} ] } ] }
    // 2) [ { frame, time, points: [ {x,y} ] } ] -> convert to type 'point'
    // 3) { [frame]: [ {x,y} ] } -> convert to type 'point'

    const incoming = {};
    if (Array.isArray(data)) {
      data.forEach(fr => {
        const frame = Math.round(Number(fr.frame));
        if (!isFinite(frame)) return;
        if (!incoming[frame]) incoming[frame] = [];
        const arr = fr.markers || fr.points || [];
        arr.forEach(m => {
          incoming[frame].push(normalizeMarker(m));
        });
      });
    } else if (data && Array.isArray(data.markers)) {
      data.markers.forEach(fr => {
        const frame = Math.round(Number(fr.frame));
        if (!isFinite(frame)) return;
        if (!incoming[frame]) incoming[frame] = [];
        const arr = fr.markers || fr.points || [];
        arr.forEach(m => {
          incoming[frame].push(normalizeMarker(m));
        });
      });
      // If FPS exists in meta, set it (hint only)
      if (data.meta && data.meta.fps && isFinite(data.meta.fps)) {
        fpsInput.value = Number(data.meta.fps);
      }
    } else if (data && typeof data === 'object') {
      Object.keys(data).forEach(k => {
        const frame = Math.round(Number(k));
        if (!isFinite(frame)) return;
        if (!incoming[frame]) incoming[frame] = [];
        const arr = data[k] || [];
        arr.forEach(m => incoming[frame].push(normalizeMarker(m)));
      });
    }

    applyImportedMarkers(incoming, replace);
  }

  function loadAnnotationsFromCsvText(text, replace) {
    const lines = String(text).split(/\r?\n/).filter(l => l.trim().length);
    if (!lines.length) return;
    const header = lines[0].split(',').map(s => s.trim());
    const rows = lines.slice(1);
    const incoming = {};

    // Detect format: new has 'type' in header; old has 'point_index' without 'type'
    const idx = (name) => header.indexOf(name);
    const hasType = idx('type') !== -1;
    // support alternative px/py column names when x/y are missing
    const xIndexFallback = idx('x') !== -1 ? idx('x') : idx('px');
    const yIndexFallback = idx('y') !== -1 ? idx('y') : idx('py');

    if (hasType) {
      const fi = idx('frame');
      const ti = idx('time_seconds');
      const mi = idx('marker_index');
      const ty = idx('type');
      const x = idx('x');
      const y = idx('y');
      const x2 = idx('x2');
      const y2 = idx('y2');
      const cx = idx('cx');
      const cy = idx('cy');
      const rad = idx('radius');
      rows.forEach(line => {
        const cols = line.split(',');
        const frame = Math.round(Number(cols[fi]));
        if (!isFinite(frame)) return;
        const type = (cols[ty] || 'point').trim();
        if (!incoming[frame]) incoming[frame] = [];
        if (type === 'point') {
          const xi = (x !== -1) ? x : xIndexFallback;
          const yi = (y !== -1) ? y : yIndexFallback;
          incoming[frame].push({ type: 'point', x: num(cols[xi]), y: num(cols[yi]) });
        } else if (type === 'box') {
          incoming[frame].push({ type: 'box', x1: num(cols[x]), y1: num(cols[y]), x2: num(cols[x2]), y2: num(cols[y2]) });
        } else if (type === 'circle') {
          incoming[frame].push({ type: 'circle', cx: num(cols[cx]), cy: num(cols[cy]), radius: num(cols[rad]) });
        }
      });
    } else {
      // Old format: frame,time_seconds,point_index,x,y
      const fi = idx('frame');
      const x = idx('x') !== -1 ? idx('x') : idx('px');
      const y = idx('y') !== -1 ? idx('y') : idx('py');
      rows.forEach(line => {
        const cols = line.split(',');
        const frame = Math.round(Number(cols[fi]));
        if (!isFinite(frame)) return;
        if (!incoming[frame]) incoming[frame] = [];
        incoming[frame].push({ type: 'point', x: num(cols[x]), y: num(cols[y]) });
      });
    }

    applyImportedMarkers(incoming, replace);
  }

  function num(v) { const n = Number(v); return isFinite(n) ? Math.round(n) : 0; }

  function normalizeMarker(m) {
    if (!m) return null;
    if (!m.type) {
      // accept alternative px/py fields when x/y missing
      const xVal = (isFinite(m.x) ? m.x : (isFinite(m.px) ? m.px : undefined));
      const yVal = (isFinite(m.y) ? m.y : (isFinite(m.py) ? m.py : undefined));
      if (isFinite(xVal) && isFinite(yVal)) return { type: 'point', x: num(xVal), y: num(yVal) };
      // otherwise ignore
      return null;
    }
    if (m.type === 'point') {
      const xVal = (isFinite(m.x) ? m.x : (isFinite(m.px) ? m.px : undefined));
      const yVal = (isFinite(m.y) ? m.y : (isFinite(m.py) ? m.py : undefined));
      return { type: 'point', x: num(xVal), y: num(yVal) };
    }
    if (m.type === 'box') return { type: 'box', x1: num(m.x1), y1: num(m.y1), x2: num(m.x2), y2: num(m.y2) };
    if (m.type === 'circle') return { type: 'circle', cx: num(m.cx), cy: num(m.cy), radius: num(m.radius) };
    return null;
  }

  function applyImportedMarkers(incoming, replace) {
    if (replace) {
      for (const k in markers) delete markers[k];
    }
    Object.keys(incoming).forEach(k => {
      const frame = Number(k);
      if (!markers[frame]) markers[frame] = [];
      incoming[frame].forEach(m => { if (m) markers[frame].push(m); });
    });
    drawFrameOverlay();
    updateFrameLabels();
  }

  // Canvas mouse handlers for drawing markers
  function getCanvasCoords(ev) {
    const rect = canvas.getBoundingClientRect();
    const cssX = ev.clientX - rect.left;
    const cssY = ev.clientY - rect.top;
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return { x: cssX * scaleX, y: cssY * scaleY };
  }

  canvas.addEventListener('mousedown', (ev) => {
    if (!video.videoWidth || !video.videoHeight) return;
    const coords = getCanvasCoords(ev);
    const frame = getCurrentFrameIndex();

    if (ev.shiftKey) {
      // remove nearest marker within threshold
      const arr = markers[frame] || [];
      if (arr.length === 0) return;
      let bestIdx = -1; let bestDist = Infinity;
      for (let i=0; i<arr.length; i++){
        const m = arr[i];
        let d = Infinity;
        if (!m.type || m.type === 'point') {
          d = Math.hypot(m.x - coords.x, m.y - coords.y);
        } else if (m.type === 'box') {
          // distance to box center
          const cx = (m.x1 + m.x2) / 2;
          const cy = (m.y1 + m.y2) / 2;
          d = Math.hypot(cx - coords.x, cy - coords.y);
        } else if (m.type === 'circle') {
          d = Math.hypot(m.cx - coords.x, m.cy - coords.y);
        }
        if (d < bestDist) { bestDist = d; bestIdx = i; }
      }
      if (bestDist < 30) {
        const removed = arr.splice(bestIdx, 1)[0]; 
        markers[frame] = arr;
        undoStack.push({ type: 'remove', frame, point: removed }); 
        redoStack.length = 0;
        drawFrameOverlay();
      }
      return;
    }

    // Start drag
    isDragging = true;
    dragStartX = coords.x;
    dragStartY = coords.y;
    dragCurrentX = coords.x;
    dragCurrentY = coords.y;
  });

  // Mouse wheel scrubbing over canvas: step frames up/down
  canvas.addEventListener('wheel', (e) => {
    if (!video.videoWidth) return;
    e.preventDefault();
    const step = parseInt(frameStepInput.value) || 1;
    const delta = Math.sign(e.deltaY);
    let idx = getCurrentFrameIndex() + (delta > 0 ? step : -step);
    idx = Math.max(0, idx);
    seekToFrame(idx);
  }, { passive: false });

  canvas.addEventListener('mousemove', (ev) => {
    if (!isDragging) return;
    const coords = getCanvasCoords(ev);
    dragCurrentX = coords.x;
    dragCurrentY = coords.y;
    drawFrameOverlay();
  });

  canvas.addEventListener('mouseup', (ev) => {
    if (!isDragging) return;
    isDragging = false;

    const coords = getCanvasCoords(ev);
    const frame = getCurrentFrameIndex();
    const mode = document.querySelector('input[name="annotationMode"]:checked').value;

    if (!markers[frame]) markers[frame] = [];

    const dragDist = Math.hypot(coords.x - dragStartX, coords.y - dragStartY);

    if (mode === 'point') {
      // Simple click adds a point
      const pt = { type: 'point', x: Math.round(dragStartX), y: Math.round(dragStartY) };
      markers[frame].push(pt);
      undoStack.push({ type: 'add', frame, point: pt });
      redoStack.length = 0;
    } else if (mode === 'box') {
      // Only create box if dragged significantly (more than 5 pixels)
      if (dragDist > 5) {
        const box = { 
          type: 'box', 
          x1: Math.round(dragStartX), 
          y1: Math.round(dragStartY), 
          x2: Math.round(coords.x), 
          y2: Math.round(coords.y) 
        };
        markers[frame].push(box);
        undoStack.push({ type: 'add', frame, point: box });
        redoStack.length = 0;
      } else {
        // Small drag, treat as point click
        const pt = { type: 'point', x: Math.round(dragStartX), y: Math.round(dragStartY) };
        markers[frame].push(pt);
        undoStack.push({ type: 'add', frame, point: pt });
        redoStack.length = 0;
      }
    } else if (mode === 'circle') {
      // Only create circle if dragged significantly
      if (dragDist > 5) {
        const circle = { 
          type: 'circle', 
          cx: Math.round(dragStartX), 
          cy: Math.round(dragStartY), 
          radius: Math.round(dragDist) 
        };
        markers[frame].push(circle);
        undoStack.push({ type: 'add', frame, point: circle });
        redoStack.length = 0;
      } else {
        // Small drag, treat as point click
        const pt = { type: 'point', x: Math.round(dragStartX), y: Math.round(dragStartY) };
        markers[frame].push(pt);
        undoStack.push({ type: 'add', frame, point: pt });
        redoStack.length = 0;
      }
    }

    drawFrameOverlay();
  });

  canvas.addEventListener('mouseleave', () => {
    if (isDragging) {
      isDragging = false;
      drawFrameOverlay();
    }
  });

  // Export JSON or CSV
  exportBtn.addEventListener('click', () => {
    const wantCsv = exportFormatCsv.checked;
    const fps = estimateFPS();
    const out = [];
    
    // Build array of {frame, time, markers:[...]}
    for (const k of Object.keys(markers).sort((a,b)=>Number(a)-Number(b))) {
      const markerArr = markers[k];
      if (!markerArr || markerArr.length === 0) continue;
      const frameNum = Number(k);
      const timeSec = +(frameNum / fps).toFixed(4);
      
      // Keep full marker data with type information
      out.push({ frame: frameNum, time: timeSec, markers: markerArr });
    }
    
    // produce a safe filename base from uploaded filename or default
    function safeBaseName(name) {
      if (!name) return 'markers';
      // strip extension and unsafe chars
      const base = name.replace(/\.[^.]+$/, '');
      return base.replace(/[^a-zA-Z0-9-_\.]/g, '_');
    }
    const base = safeBaseName(uploadedFilename);
    // local YYYYMMDD_HHMMSS
    const dt = new Date();
    const pad = (n, z=2) => String(n).padStart(z,'0');
    const tsForName = `${dt.getFullYear()}${pad(dt.getMonth()+1)}${pad(dt.getDate())}_${pad(dt.getHours())}${pad(dt.getMinutes())}${pad(dt.getSeconds())}`;
    const outNameBase = `${base}_${tsForName}`;
    
    if (wantCsv) {
      // CSV columns: frame,time_seconds,marker_index,type,x,y,x2,y2,cx,cy,radius
      let rows = ['frame,time_seconds,marker_index,type,x,y,x2,y2,cx,cy,radius'];
      out.forEach(item => {
        item.markers.forEach((m, i) => {
          const idx = i + 1;
          if (!m.type || m.type === 'point') {
            rows.push(`${item.frame},${item.time},${idx},point,${m.x},${m.y},,,,,`);
          } else if (m.type === 'box') {
            rows.push(`${item.frame},${item.time},${idx},box,${m.x1},${m.y1},${m.x2},${m.y2},,,`);
          } else if (m.type === 'circle') {
            rows.push(`${item.frame},${item.time},${idx},circle,,,,,${m.cx},${m.cy},${m.radius}`);
          }
        });
      });
      const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = outNameBase + '.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
    } else {
      // JSON: include metadata and full marker data
      const exportMeta = { 
        filename: uploadedFilename || null, 
        exported_at: new Date().toISOString(), 
        fps: estimateFPS() 
      };
      const blob = new Blob([JSON.stringify({ meta: exportMeta, markers: out }, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = outNameBase + '.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
  });

  // Undo / Redo logic
  undoBtn.addEventListener('click', () => { performUndo(); });
  redoBtn.addEventListener('click', () => { performRedo(); });

  function performUndo() {
    const op = undoStack.pop(); if (!op) return;
    // helper to compare markers by type/props when reference match fails
    const markersEqual = (a, b) => {
      if (!a || !b) return false;
      if ((a.type || 'point') !== (b.type || 'point')) return false;
      const t = a.type || 'point';
      if (t === 'point') return Number(a.x) === Number(b.x) && Number(a.y) === Number(b.y);
      if (t === 'box') return Number(a.x1) === Number(b.x1) && Number(a.y1) === Number(b.y1) && Number(a.x2) === Number(b.x2) && Number(a.y2) === Number(b.y2);
      if (t === 'circle') return Number(a.cx) === Number(b.cx) && Number(a.cy) === Number(b.cy) && Number(a.radius) === Number(b.radius);
      return false;
    };

    if (op.type === 'add') {
      const arr = markers[op.frame] || [];
      // prefer reference equality (exact object), fallback to property match
      let idx = arr.indexOf(op.point);
      if (idx === -1) idx = arr.findIndex(p => markersEqual(p, op.point));
      if (idx >= 0) arr.splice(idx,1);
      redoStack.push(op);
    } else if (op.type === 'remove') {
      if (!markers[op.frame]) markers[op.frame] = [];
      // restore at end of array to preserve original ordering roughly
      markers[op.frame].push(op.point);
      redoStack.push(op);
    } else if (op.type === 'clear-frame') {
      markers[op.frame] = op.prevState || [];
      redoStack.push(op);
    } else if (op.type === 'clear-all') {
      // restore prevState which is a shallow copy
      for (const k in markers) delete markers[k];
      Object.assign(markers, op.prevState || {});
      redoStack.push(op);
    }
    drawFrameOverlay();
  }

  function performRedo() {
    const op = redoStack.pop(); if (!op) return;
    const markersEqual = (a, b) => {
      if (!a || !b) return false;
      if ((a.type || 'point') !== (b.type || 'point')) return false;
      const t = a.type || 'point';
      if (t === 'point') return Number(a.x) === Number(b.x) && Number(a.y) === Number(b.y);
      if (t === 'box') return Number(a.x1) === Number(b.x1) && Number(a.y1) === Number(b.y1) && Number(a.x2) === Number(b.x2) && Number(a.y2) === Number(b.y2);
      if (t === 'circle') return Number(a.cx) === Number(b.cx) && Number(a.cy) === Number(b.cy) && Number(a.radius) === Number(b.radius);
      return false;
    };

    if (op.type === 'add') {
      if (!markers[op.frame]) markers[op.frame] = [];
      markers[op.frame].push(op.point);
      undoStack.push(op);
    } else if (op.type === 'remove') {
      const arr = markers[op.frame] || [];
      let idx = arr.indexOf(op.point);
      if (idx === -1) idx = arr.findIndex(p => markersEqual(p, op.point));
      if (idx >= 0) arr.splice(idx,1);
      undoStack.push(op);
    } else if (op.type === 'clear-frame') {
      const prev = markers[op.frame];
      op.prevState = prev;
      delete markers[op.frame];
      undoStack.push(op);
    } else if (op.type === 'clear-all') {
      const prev = {};
      for (const k in markers) prev[k] = markers[k];
      for (const k in markers) delete markers[k];
      undoStack.push(op);
    }
    drawFrameOverlay();
  }

  // Keyboard shortcuts
  // Left/Right: prev/next frame, Space: play/pause, C: clear markers for current frame, D: delete nearest (same as shift+click), S: export
  document.addEventListener('keydown', (e) => {
    const tag = document.activeElement && document.activeElement.tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA') return; // don't hijack typing
    if (e.key === 'ArrowLeft') { e.preventDefault(); prevBtn.click(); }
    else if (e.key === 'ArrowRight') { e.preventDefault(); nextBtn.click(); }
    else if (e.key === ' ') { e.preventDefault(); playPauseBtn.click(); }
    else if (e.key === 'c' || e.key === 'C') { e.preventDefault(); // clear current frame markers
      const f = getCurrentFrameIndex(); 
      if (markers[f]) { 
        const prev = markers[f].slice(); 
        undoStack.push({ type:'clear-frame', frame:f, prevState: prev }); 
        redoStack.length = 0;
        delete markers[f]; 
        drawFrameOverlay(); 
      }
    }
    else if (e.key === 'd' || e.key === 'D') { e.preventDefault(); // delete nearest marker to center (user can move mouse then press D)
      // find mouse position over canvas; if none, use center
      const rect = canvas.getBoundingClientRect();
      const mx = (lastMousePos.x !== undefined) ? lastMousePos.x : rect.left + rect.width/2;
      const my = (lastMousePos.y !== undefined) ? lastMousePos.y : rect.top + rect.height/2;
      const cssX = mx - rect.left; const cssY = my - rect.top;
      const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
      const x = cssX * scaleX; const y = cssY * scaleY;
      const frame = getCurrentFrameIndex();
      const arr = markers[frame] || [];
      if (arr.length === 0) return;
      let bestIdx = -1; let bestDist = Infinity;
      for (let i=0; i<arr.length; i++){
        const m = arr[i];
        let d = Infinity;
        if (!m.type || m.type === 'point') {
          d = Math.hypot(m.x - x, m.y - y);
        } else if (m.type === 'box') {
          const cx = (m.x1 + m.x2) / 2;
          const cy = (m.y1 + m.y2) / 2;
          d = Math.hypot(cx - x, cy - y);
        } else if (m.type === 'circle') {
          d = Math.hypot(m.cx - x, m.cy - y);
        }
        if (d < bestDist) { bestDist = d; bestIdx = i; }
      }
      if (bestDist < 40) { 
        const removed = arr.splice(bestIdx, 1)[0];
        markers[frame] = arr; 
        undoStack.push({ type: 'remove', frame, point: removed }); 
        redoStack.length = 0;
        drawFrameOverlay(); 
      }
    }
    else if (e.key === 's' || e.key === 'S') { e.preventDefault(); exportBtn.click(); }
  });

  // track last mouse pos over canvas for keyboard delete
  let lastMousePos = {};
  canvas.addEventListener('mousemove', (ev) => { lastMousePos.x = ev.clientX; lastMousePos.y = ev.clientY; });

  clearBtn.addEventListener('click', () => {
    const prev = {};
    for (const k in markers) prev[k] = markers[k];
    undoStack.push({ type: 'clear-all', prevState: prev });
    for (const k in markers) delete markers[k];
    drawFrameOverlay();
  });

  // goto frame
  gotoFrameBtn.addEventListener('click', () => {
    const v = parseInt(gotoFrameInput.value);
    if (!isFinite(v) || v < 0) return;
    seekToFrame(v);
  });
  firstFrameBtn.addEventListener('click', () => { seekToFrame(0); });

  // Show FPS warning on hover (tooltip handled by title); make icon visible if fps is estimated
  fpsWarn.addEventListener('dblclick', () => { fpsInput.removeAttribute('readonly'); fpsInput.focus(); });
  fpsInput.addEventListener('input', () => { fpsWarn.style.visibility = 'hidden'; });

  // small UI update loop to keep labels updated when video playing or seeking
  setInterval(() => {
    if (video.readyState >= 2) {
      updateFrameLabels();
    }
  }, 250);

  // Initial placeholder canvas size
  canvas.width = 640; canvas.height = 360;
  ctx.fillStyle = '#222'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#999'; ctx.font = '14px sans-serif'; ctx.fillText('Load a video to start, drag and drop a video file here', 10, 30);
  </script>

  <!-- Teach Me collapsible tutorial -->
  <div style="margin-top:18px; border-top:1px solid #eee; padding-top:12px;">
    <button id="teachBtn" style="padding:8px 12px; background:#c00; color:#fff; border:1px solid #900; border-radius:4px;">Teach Me!</button>
    <div id="teachSection" style="display:none; margin-top:12px; background:#fafafa; border:1px solid #eee; padding:12px;">
      <h3>Quick start</h3>
      <ol>
        <li>Click "Choose file" or drag & drop a video onto the page.</li>
        <li>Optionally import existing annotations (JSON/CSV) using the Import control or by dropping the file anywhere. You'll be asked to Replace or Merge.</li>
        <li><span style="color:red">Manually set the FPS (frames per seconds) of the video. Currently the FPS auto-detection is typically wrong.</span></li>
        <li>Scrub the video with the timeline slider (pauses while dragging, resumes on release) or use the mouse wheel over the canvas to step frames by the configured step size.</li>
        <li>Choose your annotation mode: <strong>Point</strong>, <strong>Bounding Box</strong>, or <strong>Circle</strong>.</li>
        <li>Use Prev / Next or Arrow keys to step frames (adjust "frames per step" if you need larger jumps).</li>
        <li>Click or click-and-drag on the canvas to add markers. Shift+Click removes the nearest marker on that frame.</li>
        <li>Use Undo / Redo to revert changes. Press <kbd>S</kbd> to export, or click Export (choose JSON or CSV).</li>
      </ol>

      <h3>Detailed instructions</h3>
  <p><strong>Uploading:</strong> Use the file picker or drag & drop your video file. The tool will try to estimate the video's FPS; if it shows a warning (⚠), double-click it to edit the FPS manually for exact frame mapping.</p>
  <p><strong>Importing annotations:</strong> You can import annotations from JSON or CSV either via the Import control (next to Export) or by dropping the file anywhere on the page. You'll be prompted to <em>Replace</em> existing annotations or <em>Merge</em> into them. Supported formats:
  <br>• JSON (this tool's export): { meta, markers: [ { frame, time, markers: [ {type:'point'|'box'|'circle', ...coords} ] } ] }
  <br>• Legacy JSON: [ { frame, time, points: [ {x,y} ] } ] or { [frame]: [ {x,y} ] }
  <br>• CSV (this tool's export): frame,time_seconds,marker_index,type,x,y,x2,y2,cx,cy,radius
  <br>• Legacy CSV: frame,time_seconds,point_index,x,y (points only)</p>
      <p><strong>Navigating frames:</strong> Click "Prev" / "Next" or use the Left/Right arrow keys. The "frames per step" input controls how many frames are skipped when stepping. You can also jump to a specific frame number using the "Go to frame" input and button, or return to the first frame with "First Frame".</p>
      <p><strong>Annotation Modes:</strong></p>
      <ul>
        <li><strong>Point:</strong> Click to place a single point marker at that location.</li>
        <li><strong>Bounding Box:</strong> Click and drag to draw a rectangular box. If you only click (drag less than 5 pixels), a point will be added instead.</li>
        <li><strong>Circle:</strong> Click and drag to draw a circle. The click location becomes the center, and the drag distance becomes the radius. Small drags (less than 5 pixels) create a point instead.</li>
      </ul>
      <p><strong>Removing markers:</strong> Shift+Click near a marker to remove it. Press <kbd>D</kbd> to delete the nearest marker to the mouse cursor (or center if cursor is not over the canvas). Press <kbd>C</kbd> to clear all markers on the current frame.</p>
      <p><strong>Undo / Redo:</strong> Use the Undo and Redo buttons to step through recent add/remove/clear actions. Clearing the current frame or all markers is also undoable.</p>
      <p><strong>Exporting:</strong> Choose JSON or CSV format. JSON exports include metadata (filename, export timestamp, fps) plus markers grouped by frame with time in seconds and full marker data (type and coordinates). CSV exports one row per marker with columns: frame, time_seconds, marker_index, type, x, y, x2, y2, cx, cy, radius (with empty fields for inapplicable coordinates). Filenames are based on the original filename plus a local timestamp.</p>

      <h3>Features (at a glance)</h3>
      <ul>
        <li>Video upload via file picker or drag & drop</li>
        <li>Import annotations from JSON/CSV (replace or merge)</li>
        <li>Elegant scrubbing with a timeline slider and mouse wheel stepping</li>
        <li>Three annotation modes: Point, Bounding Box, and Circle</li>
        <li>Per-frame marking with pixel coordinates</li>
        <li>Visual preview while dragging boxes/circles</li>
        <li>Estimated FPS detection; editable FPS override</li>
        <li>Frame navigation (Prev/Next, keyboard arrows, jump to frame, first frame)</li>
        <li>Undo / Redo for all marker operations</li>
        <li>Export JSON (with metadata and full marker data) or CSV (with type column and all coordinate fields)</li>
        <li>Keyboard shortcuts: ← → (frame), Space (play/pause), C (clear frame), D (delete nearest), S (export)</li>
      </ul>
      <p class="hint">Click "Teach Me!" again to hide this tutorial.</p>
    </div>
  </div>

  <script>
    // Teach Me toggle
    const teachBtn = document.getElementById('teachBtn');
    const teachSection = document.getElementById('teachSection');
    teachBtn.addEventListener('click', () => {
      if (teachSection.style.display === 'none') {
        teachSection.style.display = 'block';
        teachBtn.textContent = 'Hide Tutorial';
      } else {
        teachSection.style.display = 'none';
        teachBtn.textContent = 'Teach Me!';
      }
    });
  </script>
</body>
</html>
